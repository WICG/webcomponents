<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'/>
    <title>Shadow DOM</title>
    <script src='./autolink-config.js' class='remove'></script>
    <script src='../../assets/scripts/autolink.js' class='remove'></script>
    <link rel="stylesheet" href="../../assets/styles/respec-complement.css" type="text/css" />
    <script src='//www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus: "ED",
          shortName: "shadow-dom",
          editors: [{ name: "Dimitri Glazkov", url: "mailto:dglazkov@chromium.org", company: "Google, Inc." },
                    { name: "Hayato Ito", url: "mailto:hayato@google.com", company: "Google, Inc." }],
          wg: "W3C Web Applications (WebApps)",
          wgURI: "http://www.w3.org/2008/webapps/",
          wgPublicList: "public-webapps",
          wgPatentURI: "",
          edDraftURI: "http://w3c.github.io/webcomponents/spec/shadow/",
          otherLinks: [
              {
                  key: "Revision history",
                  href: "https://github.com/w3c/webcomponents/commits/gh-pages/spec/shadow/"
              },
              {
                  key: "Bugs filed",
                  href: "https://github.com/w3c/webcomponents/issues"
              }
          ],
          preProcess: [resolveAutolink],
          localBiblio: {
              "EDITING": {
                  title: "HTML Editing APIs",
                  href: "https://dvcs.w3.org/hg/editing/raw-file/tip/editing.html",
                  authors:  ["Aryeh Gregor"]
              }
          }
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This specification describes a method of combining multiple DOM trees into one hierarchy and how these trees interact with each other within a document, thus
        enabling better composition of the DOM.
      </p>

    </section>

    <section id='sotd'>
    </section>

    <section>
      <h2>Conformance</h2>

      <p>All diagrams, examples, notes, are non-normative, as well as sections explicitly marked as non-normative. Everything else in this specification is normative.</p>

      <p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this document are to be interpreted as described in [[!RFC2119]]. For readability, these words do not appear in all uppercase letters in this specification.</p>

      <p>To help with layering and to avoid circular dependencies between various parts of specification, this document consists of three consecutive narratives:</p>
      <ol>
        <li>setting up the stage for the specification,</li>
        <li>explaining of the conceptual model and algorithms behind it, and</li>
        <li>expressing this model with DOM interfaces and HTML elements.</li>
      </ol>

      <p>In a sense, these parts can be viewed as <em>math</em>, which sets up the reasoning environment, <em>physics</em>, which is the theoretical reasoning about the concept, and <em>mechanics</em>, which is the practical application of this reasoning.</p>

      <p>Any point, at which a conforming UA must make decisions about the state or reaction to the state of the conceptual model, is captured as <a href="http://en.wikipedia.org/wiki/Algorithm">algorithm</a>. The algorithms are defined in terms of processing equivalence. The <dfn>processing equivalence</dfn> is a constraint imposed on the algorithm implementors, requiring the output of the both UA-implemented and the specified algorithm to be exactly the same for all inputs.</p>
    </section>

    <section>
      <h2>Concepts</h2>

      <section class="informative">
        <h3>Introduction</h3>

        <p>
          See the <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/">Shadow DOM 101</a> as a non-normative introduction.
        </p>
      </section>

      <section>
        <h3>Shadow trees</h3>

        <p>A <dfn>document tree</dfn> is a <a>node tree</a> [[!DOM]] whose <a>root</a> <a>node</a> is a <a>document</a>.</p>

        <p>Any element can <dfn title="hosts">host</dfn> zero or one associated <a title="node tree">node trees</a>, called a <dfn>shadow tree</dfn>.

        <p>A <dfn>shadow host</dfn> is an element that <a>hosts</a> one <a title="node tree">shadow tree</a>.

        <p>A shadow tree has an associated flag, called an <dfn>encapsulation mode</dfn>, which is either <dfn>open</dfn> or <dfn>closed</dfn>.

        <p>A <dfn>shadow root</dfn> is the <a>root</a> <a>node</a> of a shadow tree.</p>

        <p>
          A node <var>A</var> is called a <dfn>deep child</dfn> of a node <var>B</var>,
          if either <var>A</var> is a child of <var>B</var> or A is the <a>root</a> node of the <a>shadow tree</a> that B <a>hosts</a>.
        </p>

        <p>
          A node <var>A</var> is called a <dfn>deep descendant</dfn> of a node <var>B</var>,
          if either <var>A</var> is a <a>deep child</a> of <var>B</var>
          or <var>A</var> is a <a>deep child</a> of a node <var>C</var> that is a <a>deep descendant</a> of <var>B</var>.
        </p>

        <p>
          An <dfn>inclusive deep descendant</dfn> is a node or one of its <a title="deep descendant">deep descendants</a>.
        </p>

        <p>
          A node <var>A</var> is called a <dfn>deep parent</dfn> of a node <var>B</var>
          if and only if <var>B</var> is a <a>deep child</a> of <var>A</var>.
        </p>

        <p>
          A node <var>A</var> is called a <dfn>deep ancestor</dfn> of a node <var>B</var>
          if and only if <var>B</var> is a <a>deep descendant</a> of <var>A</var>.
        </p>

        <p>
          An <dfn>inclusive deep ancestor</dfn> is a node or one of its <a title="deep ancestor">deep ancestors</a>.
        </p>

        <p>
          When an element is an <a>inclusive deep descendant</a> of a <a>document element</a>, it is <dfn>in a document deeply</dfn>.
        </p>

      </section>

      <section>
        <h3>Trees of trees</h3>

        <p>A <dfn>tree of trees</dfn> is a <a>tree</a> of <a title="node tree">node trees</a>.</p>

        <p class="note">
          The purpose of introducing a tree of trees here is to define algorithms easily in the following sections.
          This is a kind of a notation techchique to make the this specification simpler.
        </p>

        <p>Just like a <a>node tree</a> is defined as <a title="tree">a set of relationships</a> between <a title="node">nodes</a>,
          a <a>tree of trees</a> is similarly defined as a set of relationships between <a title="node tree">node trees</a>:</p>
        <ul>
          <li>
            A <a>node tree</a> <var>A</var> is called a <dfn>parent tree</dfn> of a <a>node tree</a> <var>B</var> if B is a shadow tree and the shadow host which hosts <var>B</var> partitipates in <var>A</var>.
          </li>
          <li>If there is more than one <a>node tree</a> that shares the same <a>parent tree</a>, the <a>tree order</a> between them in the <a>tree of trees</a> is defined as follows:
            <ol>
              <li>Let <var>A</var> and <var>B</var> be <a title="node tree">node trees</a> that share the same <a>parent tree</a>.</li>
              <li><var>A</var> comes before <var>B</var> if the <a>shadow host</a> which <a>hosts</a> <var>A</var> is <a>preceding</a> the <a>shadow host</a> which <a>hosts</a> <var>B</var>.</li>
            </ol>
          </li>
          <li>Other relationships and terms, such as <dfn>root tree</dfn>, <dfn>child tree</dfn>,
            <dfn>descendant tree</dfn>, <dfn>inclusive descendant tree</dfn>,
            <dfn>ancestor tree</dfn>, <dfn>inclusive ancestor tree</dfn>,
            <dfn>preceding tree</dfn>
            are defined in the similar way as defined in <a title="tree">trees</a>.</li>
        </ul>

        <p>
          A <a>node tree</a> <var>A</var> is called an <dfn>unclosed tree</dfn> of a <a>node tree</a> <var>B</var> if and only if one, at least, of the following conditions is satisfied:
        </p>

        <ul>
          <li><var>A</var> is an <a>inclusive ancestor tree</a> of <var>B</var>.</li>
          <li>The <a>encapsulation mode</a> of <var>A</var> is <a>open</a> and <var>A</var> is a <a>child tree</a> of <var>B</var>.</li>
          <li><var>A</var> is an <a>unclosed tree</a> of a <a>node tree</a> <var>C</var> that is an <a>unclosed tree</a> of <var>B</var>.</li>
        </ul>

        <p>
          A node <var>A</var> is called an <dfn>unclosed node</dfn> of a node <var>B</var> if and only if the <a>node tree</a> that <var>A</var> <a>participates</a> in
          is an <a>unclosed tree</a> of the <a>node tree</a> that <var>B</var> <a>participates</a> in.
        </p>

        <p>The <a><code>ownerDocument</code></a> property of a <a>node</a> in a shadow tree <strong>must</strong> refers to the <a>document</a> of the <a>shadow host</a> which <a>hosts</a> the shadow tree.</p>

        <p><a><code>Window</code></a> object <a title="named access on the window object">named properties</a> [[!HTML]] <strong>must</strong> access the <a title="node">nodes</a> in the <a>document tree</a>.</p>

        <section class="informative">
          <h3>Example tree of trees</h3>

          <figure>
            <object data="../../assets/images/tree-of-trees.svg" width="650" height="823"></object>
            <figcaption>
              A tree of trees.
            </figcaption>
          </figure>

          <p>
            In the figure, there are six node trees, named <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code> and <code>F</code>.
            The shadow trees, <code>B</code>, <code>C</code> and <code>D</code>, are hosted by elements which participate in the document tree <code>A</code>.
            The shadow trees, <code>E</code> and <code>F</code>, are hosted by elements which participates in the shadow tree <code>D</code>.
            The following set of relationships holds in the figure:
          </p>
          <ul>
            <li>The ordered list of <code>A</code>'s <a title="child tree">child trees</a> is [<code>B</code>, <code>C</code>, <code>D</code>].</li>
            <li>The ordered list of <code>B</code>'s <a title="child tree">child trees</a> is [].</li>
            <li>The ordered list of <code>C</code>'s <a title="child tree">child trees</a> is [].</li>
            <li>The ordered list of <code>D</code>'s <a title="child tree">child trees</a> is [<code>E</code>, <code>F</code>].</li>
            <li>The ordered list of <code>E</code>'s <a title="child tree">child trees</a> is [].</li>
            <li>The ordered list of <code>F</code>'s <a title="child tree">child trees</a> is [].</li>
            <li>The document tree, <code>A</code>, is the <a>root tree</a> of the <a>tree of trees</a>.</li>
          </ul>

          <div class="note">
            <p>
              As for a relationship between nodes, it's worth mentioning that there is no <a>ancestor</a>/<a>descendant</a> relationships between two nodes if they participate in different node trees.
              A shadow root is not a <a>child</a> node of the shadow host. The <a>parent</a> node of a <a>shadow root</a> doesn't exist.
              Because of this nature, most of existing APIs are <strong>scoped</strong> and don't affect other node trees, even though they are forming one tree of trees.
              For example, <a title="getElementById"><code>document.getElementById(elementId)</code></a> never returns an element in a shadow tree,
              even when the element has the given <code>elementId</code>.
            </p>
            <p>
              The same thing also applies to CSS <a title="selectors">Selectors</a> matching.
              For example, a <a title="descendant combinators">descendant combinator</a> never descends into a node in a <a title="child tree">child</a> <a>shadow tree</a>
              because a <a>shadow root</a> is not a <a>child</a> node of the <a>shadow host</a>.
              Unless a special CSS Selector for Shadow DOM, which is mentioned later, is used, a CSS Selector never matches an element in a different node tree.
            </p>
          </div>
          <p class="note">
            Because <code>ShadowRoot</code> inherits <code>DocumentFragment</code>, as <a href="#idl-def-ShadowRoot">specified</a> later,
            you can use <code>ShadowRoot.getElementByID(elementId)</code> to get a node in the <a>shadow tree</a>.
          </p>
        </section>

      </section>

      <section>
        <h3>Composed trees</h3>

        <p>A <dfn>composed tree</dfn> is a <a>node tree</a> which is constructed out of <a title="node">nodes</a> from multiple <a title="node tree">node trees</a> in a <a>tree of trees</a>.
          The exact algorithm of constructing a composed tree is specified later.</p>

        <figure>
          <object data="../../assets/images/composed-tree.svg" width="654" height="606"></object>
          <figcaption>A composed tree</figcaption>
        </figure>

        <p>
          If an element doesn't <a>participate</a> in a <a>composed tree</a> whose <a>root</a> node is a document, the element <strong>must</strong> not appear in the <a>formating structure</a> [[!CSS21]] nor create any CSS <a>box</a>.
          This behavior <strong>must</strong> not be overridden by setting the 'display' property.
        </p>
        <p>
          In resolving CSS <a>inheritance</a>, an element <strong>must</strong> inherit from the parent node in the <a>composed tree</a>, if applicable.
        </p>

        <div class="note">
          <p>
            The editor's draft of CSS Scoping specification [[css-scoping-1]] defines the selectors which are related to Shadow DOM.
            For those who would search this Shadow DOM specifaction with the name of these selectors, mentioning these selectores here:
          </p>

          <ul>
            <li><code>:shadow</code> pseudo element</li>
            <li><code>/deep/</code> combinator,  which was replaced with a <code>>>></code> combinator (or <strong>shadow piecing descendant combinator</strong>)</li>
            <li><code>::content</code> pseudo-element</li>
            <li><code>:host-context()</code> functional pseudo-class</li>
          </ul>
        </div>
      </section>

    </section>

    <section>
      <h2>Distributions</h2>

      <section>
        <h3>Insertion Points</h3>

        <p>An <dfn>insertion point</dfn> is a defined location where <a title="node">nodes</a> in a different <a>node tree</a> appear instead of the nodes's original position when constructing a <a>composed tree</a>.</p>

        <figure>
          <object data="../../assets/images/distributions.svg" width="663" height="598"></object>
          <figcaption>A distribution</figcaption>
        </figure>

        <p>A <dfn>distribution</dfn> is the mechanism that determines which <a title="node">nodes</a> appear at each <a>insertion point</a>. The exact algorithm of a <a>distribution</a> is specified later.</p>
      </section>

      <section>
        <h3>Content Insertion Points</h3>

        <p>A <dfn>content insertion point</dfn> is an <a>insertion point</a> to where the child <a title="node">nodes</a> of the <a>shadow host</a> are distributed.
          The <a>content element</a> that satisfies all of the following conditions represents a <a>content insertion point</a>:</p>
        <ul>
          <li>The <a>root</a> <a>node</a> of the <a>content element</a> is a <a>shadow root</a></li>
          <li>There is no other <a>content element</a> in the <a title="ancestor">ancestors</a> of the <a>content element</a></li>
        </ul>
      </section>

      <section>
        <h3>Distribution Results</h3>

        <p>Each <a>tree of trees</a> has the <dfn>distribution result</dfn> which describes the result of distributions.
          The <a>distribution result</a> <strong>must</strong> be <a title="processing equivalence">equivalent</a> of the following:</p>
        <ol>
          <li>Each <a>insertion point</a> has an ordered list, called <dfn>distributed nodes</dfn>, which consists of <a title="node">nodes</a> which are distributed into the <a>insertion point</a>.</li>
          <li>Each <a>node</a> that is not an <a>insertion point</a> has an ordered list, called <dfn>destination insertion points</dfn>, which consists of <a title="insertion point">insertion points</a> to where the <a>node</a> is distributed</li>
        </ol>

        <p>An <a>insertion point</a> <var>A</var> is the <dfn>final destination</dfn> of a <a>node</a> <var>B</var> if <var>A</var> is the last item of the <a>destination insertion points</a> of <var>B</var>.</p>

        <p>When a <a>node</a> <var>A</var> is <dfn title="distributes">distributed</dfn> into an <a>insertion point</a> <var>B</var>, the following steps <strong>must</strong> happen:</p>
        <ul>
          <li>Add <var>A</var> to the <a>distributed nodes</a> of <var>B</var></li>
          <li>Add <var>B</var> to the <a>destination insertion points</a> of <var>A</var></li>
        </ul>

        <div class="note">
          <p>One case that deserves special consideration is the situation when an <a>insertion point</a> is a child <a>node</a> of another <a>shadow host</a>. In such situations, the <a title="node">nodes</a> <a title="distributes">distributed</a> into that <a>insertion point</a> appear as if they were child <a title="node">nodes</a> of the <a>shadow host</a> in the context of <a>distribution</a>. Thus, the <a title="node">nodes</a> <a title="distributes">distributed</a> to a <a>shadow tree</a> could have already been <a title="distributes">distributed</a> from its parent tree.</p>

          <p>Despite being distributed to more than one insertion point, a node still only appears once in the composed tree at the final destination.</p>
        </div>

        <figure>
          <object data="../../assets/images/re-distributions.svg" width="693" height="822"></object>
          <figcaption>A re-distribution.
            In the figure, a node <em>child 1</em> is distributed into <em>insertion point 1</em>. Then <em>child1</em> is re-distributed into <em>insertion point 3</em>.
            The destination insertion points of <em>child 1</em> is [<em>insertion point 1</em>, <em>insertion point 3</em>] and <em>insertion point 3</em> is the final destination of <em>child 1</em>.
            The distributed nodes of <em>insertion point 1</em> and <em>insertion point 3</em> is [<em>child 1</em>] and [<em>child 1</em>, <em>child 3</em>], respectively.
          </figcaption>
        </figure>

      </section>

      <section>
        <h3>Distribution Algorithms</h3>

        <p>The <dfn>distribution algorithm</dfn> <strong>must</strong> be used to determine the <a>distribution result</a> for a <a>tree of trees</a> and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>TREE-OF-TREES</var>, a <a>tree of trees</a></dd>
            <dt>Output</dt>
            <dd>The <a>distribution result</a> of <var>TREE-OF-TREES</var> is updated</dd>
          </dl>
          <ol>
            <li>Let all <a>distributed nodes</a> and <a>destination insertion points</a> owned by <a title="node">nodes</a> in <var>TREE-OF-TREES</var> be empty</li>
            <li>Let <var>ROOT-TREE</var> be the <a>root tree</a> of <var>TREE-OF-TREES</var></li>
            <li>Run the <a>distribution resolution algorithm</a> with <var>ROOT-TREE</var> as input</li>
          </ol>
        </div>

        <p>The <dfn>distribution resolution algorithm</dfn> <strong>must</strong> be used to determine the <a>distribution result</a> for a given <a>node tree</a> and its <a title="descendant tree">descendant trees</a>, and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>NODE-TREE</var>, a <a>node tree</a></dd>
            <dt>Output</dt>
            <dd>The <a>distribution result</a> is updated for the <a title="inclusive descendant tree">inclusive descendant trees</a> of <var>NODE-TREE</var></dd>
          </dl>

          <ol>
            <li>For each <a>shadow host</a>, <var>SHADOW-HOST</var>, which participates in <var>NODE-TREE</var>, in <a>tree order</a>:
              <ol>
                <li>Let <var>POOL</var> be the result of the <a>pool population algorithm</a> with <var>SHADOW-HOST</var> as input</li>
                <li>Let <var>SHADOW-TREE</var> be the <a>shadow tree</a> which <var>SHADOW_HOST</var> hosts</li>
                <li>Run the <a>pool distribution algorithm</a> with <var>SHADOW-TREE</var> and <var>POOL</var> as input</li>
                <li>Run the <a>distribution resolution algorithm</a>, recursively, with <var>SHADOW-TREE</var> as input</li>
              </ol>
          </ol>
        </div>

        <p>The <dfn>pool population algorithm</dfn> <strong>must</strong> be used to populate <a title="node">nodes</a> from the child <a title="node">nodes</a> of a given <a>node</a> and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>NODE</var>, a node</dd>
            <dt>Output</dt>
            <dd><var>POOL</var>, an ordered list of nodes</dd>
          </dl>

          <ol>
            <li>Let <var>POOL</var> be an empty ordered list.</li>
            <li>For each child <a>node</a>, <var>CHILD</var>, of <var>NODE</var>:
              <ol>
                <li>If <var>CHILD</var> is an <a>insertion point</a>:
                  <ol>
                    <li>Add all <a title="node">nodes</a> in the <a>distributed nodes</a> of <var>CHILD</var> to <var>POOL</var></li>
                  </ol></li>
                <li>Otherwise:
                  <ol>
                    <li>Add <var>CHILD</var> to <var>POOL</var></li>
                  </ol></li>
              </ol></li>
          </ol>
        </div>

        <p>The <dfn>pool distribution algorithm</dfn> <strong>must</strong> be used to distribute <a title="node">nodes</a> in a pool into the <a title="content insertion point">content insertion points</a> in a <a>shadow tree</a> and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>SHADOW-TREE</var>, a shadow tree</dd>
            <dd><var>POOL</var>, an ordered list of nodes</dd>
            <dt>Output</dt>
            <dd>Nodes in POOL are distributed into the content insertion points in the tree.</dd>
          </dl>

          <ol>
            <li>For each <a>content insertion point</a>, <var>CONTENT</var>, which participates in <var>SHADOW-TREE</var>, in tree order:
              <ol>
                <li>For each <a>node</a>, <var>NODE</var>, in <var>POOL</var>
                  <ol>
                    <li>If <var>NODE</var> satisfies <var>CONTENT</var>'s matching criteria:
                      <ol>
                        <li><a title="distributes">Distribute</a> <var>NODE</var> into <var>CONTENT</var></li>
                        <li>Remove <var>NODE</var> from <var>POOL</var></li>
                      </ol></li>
                  </ol></li>
                <li>If no <a title="node">nodes</a> are distributed to <var>CONTENT</var>:
                  <ol>
                    <li>For each child, <var>CHILD</var>, of <var>CONTENT</var>
                      <ol>
                        <li><a title="distributes">Distribute</a> <var>CHILD</var> into <var>CONTENT</var></li>
                      </ol></li>
                  </ol></li>
              </ol></li>
          </ol>

        </div>

        <p class="note">If no nodes are distributed into a <a>content insertion point</a> <var>CONTENT</var>, the child <a title="node">nodes</a> of <var>CONTENT</var> are distributed into <var>CONTENT</var> as fallback nodes.</p>

        <p>If any condition which affects the <a>distribution result</a> changes, the <a>distribution result</a> <strong>must</strong> be updated before any use of the <a>distribution result</a>.</p>

      </section>

      <section>
        <h3>Satisfying Matching Criteria</h3>

        <p>The <dfn>matching criteria</dfn> for an <a>insertion point</a> is a set of <a title="compound selector">compound selectors</a> [[!SELECTORS4]]. These <a title="compound selector">compound selectors</a> are restricted to contain only these <a title="simple selector">simple selectors</a>:</p>

        <ul>
          <li>A <a>type selector</a> or a <a>universal selector</a></li>
          <li><a title="class selector">class selector(s)</a></li>
          <li>An <a>ID selector</a></li>
          <li><a title="attribute selector">attribute selector(s)</a></li>
          <li>A <a>negation pseudo-class</a>, <code>:not()</code></li>
        </ul>

        <p>A <a>node</a> <dfn title="satisfies-matching-criteria">satisfies</dfn> a <a>matching criteria</a> only if:</p>
        <ol>
          <li>all <a title="compound selector">compound selectors</a> in the set, contain only the <a title="simple selector">simple selectors</a> specified above; and</li>
          <li>a <a>node</a> matches at least one <a title="compound selector">compound selectors</a> in the set or the set is empty.</li>
        </ol>
      </section>

    </section>

    <section>
      <h2>Composition</h2>

      <p>The <dfn>composed tree children calculation algorithm</dfn> <strong>must</strong> be used to determine the child <a title="node">nodes</a> of a <a>node</a> in the <a>composed tree</a> and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

      <div class="algorithm">
        <dl>
          <dt>Input</dt>
          <dd><var>NODE</var>, a <a>node</a> which participates in a composed tree</dd>
          <dt>Output</dt>
          <dd><var>CHILDREN</var>, the child nodes of <var>NODE</var> in the <a>composed tree</a>.</dd>
        </dl>

        <ol>
          <li>Let <var>CHILDREN</var> be an empty ordered list of nodes</li>
          <li>If <var>NODE</var> is a <a>shadow host</a>:
            <ol>
              <li>Let <var>CHILD-POOL</var> be the children of the <a>shadow root</a> which <var>NODE</var> <a>hosts</a>.</li>
            </ol></li>
          <li>Otherwise:
            <ol>
              <li>Let <var>CHILD-POOL</var> be the child <a title="node">nodes</a> of NODE</li>
            </ol></li>
          <li>For each <a>node</a>, <var>CHILD</var>, in <var>CHILD-POOL</var>:
            <ol>
              <li>If <var>CHILD</var> is an <a>insertion point</a>:
                <ol>
                  <li>For each <a>node</a>, <var>DISTRIBUTED-NODE</var>, in the <a>distributed nodes</a> of the <a>insertion point</a> <var>CHILD</var>:
                    <ol>
                      <li>If <var>CHILD</var> is the <a>final destination</a> of <var>DISTRIBUTED-NODE</var>, add <var>DISTRIBUTED-NODE</var> to <var>CHILDREN</var></li>
                    </ol></li>
                </ol></li>
              <li>Otherwise:
                <ol>
                  <li>Add <var>CHILD</var> to <var>CHILDREN</var></li>
                </ol></li>
            </ol></li>
        </ol>

      </div>

      <p>For a given <a>tree of trees</a> <var>TREE-OF-TREES</var>, the <a>composed tree</a> constructed from <var>TREE-OF-TREES</var> <strong>must</strong> be <a title="processing equivalence">equivalent</a> to the following tree:</p>
      <ul>
        <li>The <a>root</a> <a>node</a> of the <a>composed tree</a> is the <a>root</a> <a>node</a> of the <a>root tree</a> of <var>TREE-OF-TREES</var>.</li>
        <li>For a given <a>node</a> which <a>participates</a> in the <a>composed tree</a>, the child <a title="node">nodes</a> of the <a>node</a> is the result of the <a>composed tree children calculation algorithm</a> with the <a>node</a> as input.
        </li>
      </ul>
    </section>

    <section>
      <h2>Events</h2>

      <p>In each algorithm in this section, the <a>Window</a> <strong>must</strong> be considered as if it were the parent node of the <a>Document</a> so that the <a>Window</a> also receives an <a>event</a>.</p>

      <p>When an <a>event</a> is <a title="event dispatch">dispatched</a> in a <a>shadow tree</a>, its path either crosses the <a title="shadow tree">shadow trees</a> or is terminated at the <a>shadow root</a>. One exception are the <a title="mutation event">mutation events</a>. The <a title="mutation event">mutation event types</a> <strong>must</strong> never be dispatched in a <a>shadow tree</a>.</p>

      <section>
        <h3>Changes to Dispatching Events</h3>
        <p>The item 4 of <a title="event dispatch">Dispatching events</a> is changed to:
        <ol start="4">
          <li>If event’s target attribute value is participating in a tree,
            <ins>initialize the <a>scoped flag</a> if the event is a <a>scoped events</a>, and </ins>
            let event path be
            <ins>the output of the <a>event path calculation algorithm</a> with target and event as inputs.</ins>
            <del>a static ordered list of all its ancestors in tree order, and</del>
            <ins>Otherwise</ins> let event path be the empty list<del> otherwise</del>.
        </ol>
      </section>

      <section>
        <h3>Scoped Events</h3>

        <p>The <dfn>scoped events</dfn> are events whose <a>scoped flag</a> is initialized to true
          when the events are <a title="event dispatch">dispatched</a> by the user agent,
          before the event path is calculated.</p>
        <p>The following events are the scoped events, but not limited to:</p>
        <ul>
          <li><code>abort</code></li>
          <li><code>error</code></li>
          <li><code>select</code></li>
          <li><code>change</code></li>
          <li><code>load</code></li>
          <li><code>reset</code></li>
          <li><code>resize</code></li>
          <li><code>scroll</code></li>
          <li><code>selectstart</code></li>
        </ul>

        <p class="issue">
          Upstream this section into relevant specs, instead of having a fixed list here.
        </p>

      </section>

      <section>
        <h3>Event Paths</h3>

        <p>The <dfn>event path calculation algorithm</dfn> must be used to determine event path and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>NODE</var>, a node</dd>
            <dd><var>EVENT</var>, an event</dd>
            <dt>Output</dt>
            <dd><var>PATH</var>, an event path, a ordered list of an event target</dd>
          </dl>
          <ol>
            <li>Let <var>PATH</var> be the empty ordered list of nodes</li>
            <li>Let <var>CURRENT</var> be <var>NODE</var></li>
            <li>
              Repeat while <var>CURRENT</var> exists:
              <ol>
                <li>Append <var>CURRENT</var> to <var>PATH</var></li>
                <li>
                  If the <a>destination insertion points</a> of <var>CURRENT</var> is not empty:
                  <ol>
                    <li>Append each <a>insertion point</a> in the <a>destination insertion points</a> of <var>CURRENT</var>, from the first, inclusive, to the last, exclusive, to <var>PATH</var></li>
                    <li>Let <var>CURRENT</var> be the <a>final destination</a> of <var>CURRENT</var></li>
                  </ol>
                </li>
                <li>
                  Otherwise if all of the following conditions are satisfied, stop this algorithm:
                  <ol>
                    <li><var>CURRENT</var> is a shadow root</li>
                    <li><var>CURRENT</var> is the <a>root</a> node of <var>NODE</var></li>
                    <li><var>EVENT</var>'s <a>scoped flag</a> is set</li>
                  </ol>
                </li>
                <li>
                  Otherwise:
                  <ol>
                    <li>Let <var>CURRENT</var> be the <a>deep parent</a> of <var>CURRENT</var></li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </div>

        <p class="note">
          For a <a title="trusted events" >trusted event</a> that has a <code>relatedTarget</code> attribute, the event path would be trimmed. See the <a>event path trimming algorithm</a>, which is specified later.
        </p>

      </section>

      <section class="informative">
        <h3>Event Paths Example</h3>

        <p>
          Suppose we have the following tree of trees:
        </p>

        <figure>
          <object data="../../assets/images/event-path-tree-of-trees.svg" width="301" height="1074"></object>
          <figcaption>An example tree of trees. Nodes which are not involved in the example event path, which is explained later, are omitted.</figcaption>
        </figure>

        <ul>
          <li>
            <code>A</code> is a <a>document</a>.
          </li>
          <li>
            <code>E</code>, <code>J</code>, <code>N</code>, <code>Q</code> and <code>S</code> are <a title="shadow root">shadow roots</a>.
          </li>
          <li>
            <code>I</code>, <code>M</code>, <code>P</code>, <code>R</code> and <code>U</code> are <a title="content insertion point">content insertion points</a>.
          </li>
        </ul>

        <p>
          This <a>tree of trees</a> has the following 6 <a title="node tree">node trees</a>, 1 <a>document tree</a> and 5 <a title="shadow tree">shadow trees</a>:
        </p>

        <ul>
          <li>
            The <var>document tree 1</var>. Node <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code> participate in that.
          </li>
          <li>
            The <var>shadow tree 2</var> hosted by <code>B</code>. Node <code>E</code>, <code>F</code>, <code>G</code>, <code>H</code> and <code>I</code> participate in that.
          </li>
          <li>
            The <var>shadow tree 3</var> hosted by <code>H</code>. Node <code>J</code>, <code>K</code>, <code>L</code> and <code>M</code> participate in that.
          </li>
          <li>
            The <var>shadow tree 4</var> hosted by <code>K</code>. Node <code>N</code>, <code>O</code> and <code>P</code> participate in that.
          </li>
          <li>
            The <var>shadow tree 5</var> hosted by <code>O</code>. Node <code>Q</code> and <code>R</code> participate in that.
          </li>
          <li>
            The <var>shadow tree 6</var> hosted by <code>F</code>. Node <code>S</code>, <code>T</code> and <code>U</code> participate in that.
          </li>
        </ul>

        <p>
          Let's assume that the <a>distribution result</a> of this <a>tree of trees</a> is:
        </p>

        <ul>
          <li>
            The <a>destination insertion points</a> of <code>C</code> are <code>[I, M]</code> (<code>C</code> is re-distributed)
          </li>
          <li>
            The <a>destination insertion points</a> of <code>L</code> are <code>[P, R]</code> (<code>L</code> is re-distributed)
          </li>
          <li>
            The <a>destination insertion points</a> of <code>G</code> are <code>[U]</code>
          </li>
        </ul>

        <p>
          In this case, if an event is dispatched on node <code>D</code>, the event path will be:
        </p>
        <p>
          <code>[D, C, I, M, L, P, R, Q, O, N, K, J, H, G, U, T, S, F, E, B, A]</code>  (<a>Window</a> is omitted)
        </p>

        <p>
          Note that the <a>event path calculation algorithm</a> is designed to achieve the following goals:
        </p>

        <ol>
          <li>
            If there is a node, <var>CHILD</var>, in the event path and <var>CHILD</var> has a parent node, <var>PARENT</var>, in the node tree, the event path also includes <var>PARENT</var>.
            <var>PARENT</var> always appears somewhere after <var>CHILD</var> in the event path.
          </li>
          <li>
            Nodes in the event path form a <em>linear ancestor chain</em> in each <a>node tree</a>. There are no <em>branch points</em> in each <a>node tree</a>.
          </li>
        </ol>

        <figure>
          <object data="../../assets/images/event-path-node-trees.svg" width="884" height="473">></object>
          <figcaption>
            The relationship between an event path and node trees. In the figure, a number shown in a left-side of each node represents a zero-based position of each node in the event path.
            A parent node always has a larger number than that of its child node in each node tree.
          </figcaption>
        </figure>

        <p>
          That means if we focus on one <a>node tree</a> and forget all other <a title="node tree">node trees</a>,
          the event path would be seen as if the event happened only on the <a>node tree</a> which we are focused on.
          This is an important aspect in a sense that hosting shadow trees doesn't have any effect to the event path <em>within</em> the <a>node tree</a> the <a>shadow host</a> participate in
          as long as the event is not stopped somewhere in the <a title="descendant tree">descendant trees</a>.
        </p>

        <p>
          For example, from the view of the <var>document tree 1</var>, the event path would be seen as <code>[D, C, B, A]</code>.
          From the view of the <var>shadow tree 2</var>, the event path would be seen as <code>[I, H, G, F, E]</code>.
          The similar things also apply to other <a title="node tree">node trees</a>.
        </p>

        <p>
          It is also worth pointing out that if we exclude all <a title="insertion point">insertion points</a> and <a title="shadow root">shadow roots</a> from an event path,
          the result would be equivalent to the inclusive ancestors of the node on which the event is dispatched, in the composed tree.
        </p>

        <figure>
          <object data="../../assets/images/event-path-and-composed-tree.svg" width="217" height="1600"></object>
          <figcaption>
            The relationship between an event path and the <a>composed tree</a>. The event path used in the example is shown in the left-hand side and the <a>composed tree</a> is shown in the right-hand side.
            If we exclude all <a title="insertion point">insertion points</a> and <a title="shadow root">shadow roots</a> from the event path,
            the result would be equivalent to the inclusive ancestors of the node, <code>D</code>, in the <a>composed tree</a>.
          </figcaption>
        </figure>

      </section>

      <section>
        <h3>Event Retargeting</h3>

        <p>In the cases where event path is across multiple node trees, the event's information about the target of the event is adjusted in order to maintain <a href="#encapsulation">encapsulation</a>. Event <dfn>retargeting</dfn> is a process of computing relative targets for each ancestor of the <a>node</a> at which the event is dispatched. A <dfn>relative target</dfn> is a <a>node</a> that most accurately represents the target of a dispatched event at a given ancestor while maintaining the encapsulation.</p>

        <p>The <dfn>retargeting algorithm</dfn> is used to determine relative targets and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>BASE</var>, a base node for which a target node should be adjusted</dd>
            <dd><var>TARGET</var>, a target node which should be adjusted</dd>
            <dt>Output</dt>
            <dd><var>RELATIVE-TARGET</var>, a <a>relative target</a>, the result of adjusting <var>TARGET</var> for <var>BASE</var></a></dd>
          </dl>
          <ol>
            <li>Let <var>BASE-TREE</var> be the <a>node tree</a> which <var>BASE</var> <a>participates</a> in</li>
            <li>Let <var>TARGET-TREE</var> be the <a>node tree</a> which <var>TARGET</var> <a>participates</a> in</li>
            <li>If <var>BASE-TREE</var> and <var>TARGET-TREE</var> participate in the same <a>tree of trees</a>:
              <ol>
                <li>Let <var>COMMON-ANCESTOR-TREE</var> be the lowest common <a>inclusive ancestor tree</a> of <var>BASE-TREE</var> and <var>TARGET-TREE</var></li>
              </ol>
            </li>
            <li>Otherwise:
              <ol>
                <li>Let <var>COMMON-ANCESTOR-TREE</var> be the <a>root tree</a> of <var>TARGET-TREE</var></li>
              </ol>
            </li>
            <li>
              For each <a>node</a>, <var>ANCETOR</var>, in an <a>inclusive deep ancestor</a> nodes of <var>TARGET</var>, from descendants to ancestors:
              <ol>
                <li>
                  If <var>ANCESTOR</var> participates in <var>COMMON-ANCESTOR-TREE</var>:
                  <ol>
                    <li>Let <var>RELATIVE-TARGET</var> be <var>ANCESTOR</var></li>
                    <li>Stop this algorithm</li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </div>

        <p>The value of the <code>Event</code> object's <a><code>target</code></a> attribute <strong>must</strong> be the result of the <a>retargeting algorithm</a> with the event's <code>currentTarget</code> and <code>target</code> as input.</p>
        <p>The event target retargeting process <strong>must</strong> occur prior to dispatch of an event.</p>
      </section>

      <section>
        <h3>Retargeting <code>relatedTarget</code></h3>

        <p>Some events have a <a><code>relatedTarget</code></a> [[!DOM-Level-3-Events]] property, which holds a <a>node</a> that's not the event's target, but is related to the event.</p>

        <p>
          For instance, a <code>mouseover</code> event's <a><code>relatedTarget</code></a> may hold the <a>node</a> from which the mouse has moved to event's <code>target</code>. In the case where <code>relatedTarget</code> is in a <a>shadow tree</a>, the conforming UAs <strong>must</strong> not leak its actual value outside of this tree.
        </p>
        <p>
          The value of the <code>Event</code> object's <a><code>relatedTarget</code></a> attribute <strong>must</strong> be the result of the <a>retargeting algorithm</a> with the event's <code>currentTarget</code> and <code>relatedTarget</code> as input. The result is called a <dfn>relative related target</dfn>.
        </p>
        <p>
          The event relatedTarget retargeting process <strong>must</strong> occur prior to dispatch of an event.
        </p>
      </section>

      <section>
        <h3>Retargeting Touch Events</h3>

        <p>The <a><code>Touch</code></a> <a title="Touch target"><code>target</code></a> [[!TOUCH-EVENTS]] attribute <strong>must</strong> be adjusted in the same way as an event with a <a><code>relatedTarget</code></a>. Each <a><code>Touch</code></a> <a title="Touch target"><code>target</code></a> in the <a><code>TouchList</code></a> returned from <a><code>TouchEvent</code></a> <a title="touches"><code>touches()</code></a>, <a title="changedTouches"><code>changedTouches()</code></a> and <a title="targetTouches"><code>targetTouches()</code></a> must be the result of the <a>retargeting algorithm</a> with a current target and <a><code>Touch</code></a> <a title="Touch target"><code>target</code></a> as input.</p>
      </section>

      <section>
        <h3>Retargeting Focus Events</h3>

        <p>The <code>focus</code>, <code>DOMFocusIn</code>, <code>blur</code>, and <code>DOMFocusOut</code> events <strong>must</strong> be treated in the same way as events with a <code>relatedTarget</code>, where the corresponding <a>node</a> that is losing focus as a result of <code>target</code> gaining focus or the <a>node</a> that is gaining focus, and thus causing the blurring of <code>target</code> acts as the related target.</p>
      </section>

      <section>
        <h3>Event Path Trimming</h3>

        <p>
          In cases where both <code>relatedTarget</code> and <code>target</code> of a <a title="trusted events">trusted event</a> are part of the same <a>shadow tree</a>, the conforming UAs <strong>must</strong> <em>stop</em> events at the shadow root to avoid the appearance of spurious <code>mouseover</code> and <code>mouseout</code> events firing from the same node.
        </p>
        <p>
           Thus, event listeners for <a>trusted events</a> <strong>must not</strong> be invoked on a <a>node</a> for which the <code>target</code> and <code>relatedTarget</code> are the same.
        </p>

        <p>
          The <dfn>event path trimming algorithm</dfn> <strong>must</strong> be used to trim the event path for a <a title="trusted events">trusted event</a> that has a <code>relatedTarget</code> attribute and
          <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:
        </p>
        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>EVENT-PATH</var>, the event path, which is the result of the <a>event path calculation algorithm</a></dd>
            <dt>Output</dt>
            <dd><var>EVENT-PATH</var> is trimmed so that event listeners aren't invoked on a node for which the <code>target</code> and <code>relatedTarget</code> are the same.</dd>
          </dl>
          <ol>
            <li>
              For each object, <var>A</var>, in <var>EVENT-PATH</var>:
              <ol>
                <li>Let <var>RELATIVE-TARGET</var> be the <a>relative target</a> for <var>A</var></li>
                <li>Let <var>RELATIVE-RELATED-TARGET</var> be the <a>relative related target</a> for <var>A</var></li>
                <li>If <var>RELATIVE-TARGET</var> and <var>RELATIVE-RELATED-TARGET</var> are the same, remove <var>A</var> from <var>EVENT-PATH</var>.</li>
              </ol>
            </li>
          </ol>
        </div>
        <p class="note">
          For an <a title="trusted events" >untrusted event</a>, the <a>event path trimming algorithm</a> is not used.
        </p>
      </section>

      <section>
        <h3>Event Dispatch</h3>

        <p>At the time of event dispatch:</p>
        <ul>
          <li>The <a><code>MouseEvent</code></a> <a><code>offsetX</code></a> and <a><code>offsetY</code></a> attributes <strong>must</strong> return the coordinates relative to the origin of the <a>padding edge</a> of the <a>relative target</a></li>
          <li>When <em>capturing</em>, which entails processing step 6 of the <a title="event dispatch">event dispatch algorithm</a>, the event listeners <strong>must not</strong> be <a title="event listener invoke">invoked</a> on a <a>node</a> <strong>if</strong> it is the same as its <a>relative target</a></li>
          <li>When <em>bubbling</em>, which entails processing step 9 of the <a title="event dispatch">event dispatch algorithm</a>, the <a><code>Event</code></a> <a>eventPhase</a> attribute <strong>must</strong> return <a>AT_TARGET</a> <strong>if</strong> the <a>relative target</a> is same as the <a>node</a> on which event listeners are <a title="event listener invoke">invoked</a></li>
          <li>If the event's <a><code>bubbles</code></a> attribute value is <strong>false</strong>, run these substeps:
            <ol>
              <li>Reverse the order of <em>event path</em></li>
              <li>Initialize event's <a><code>eventPhase</code></a> attribute to <a><code>AT_TARGET</code></a></li>
              <li>For each object in <em>event path</em> where the <a>relative target</a> is same as the object, <a title="event listener invoke">invoke</a> its <a title="event listener">event listeners</a>, with event <em>event</em>, as long as <em>event</em>'s <a>stop propagation flag</a> is unset</li>
            </ol></li>
        </ul>

        <p>Upon completion of the event dispatch, the <a><code>Event</code></a> object's <a><code>target</code></a> and <a><code>relatedTarget</code></a> <strong>must</strong> be to the highest ancestor's <a>relative target</a>. Since it is possible for a script to hold on to the <code>Event</code> object past the scope of event dispatch, this step is necessary to avoid revealing the <a title="node">nodes</a> in <a title="shadow tree">shadow trees</a>.</p>
      </section>

      <section class="informative">
        <h3>Event Retargeting Example</h3>

        <p>Suppose we have a user interface for a media controller, represented by this tree, composed of both <a>document tree</a> and the <a title="shadow tree">shadow trees</a>. In this example, we will assume that selectors are allowed to cross the shadow boundaries and we will use these selectors to identify the <a title="element">elements</a>. Also, we will invent a fictional <code>shadow-root</code> <a>element</a> to demarcate the shadow boundaries and represent <a title="shadow root">shadow roots</a>:</p>
        <pre class="example">
&lt;div id=&quot;player&quot;&gt;
    <span class=shadow-boundary>&lt;shadow-root id=&quot;player-shadow-root&quot;&gt;</span>
        &lt;div id=&quot;controls&quot;&gt;
            &lt;button id=&quot;play-button&quot;&gt;PLAY&lt;/button&gt;
            &lt;input type=&quot;range&quot; id=&quot;timeline&quot;&gt;
                <span class=shadow-boundary>&lt;shadow-root id=&quot;timeline-shadow-root&quot;&gt;</span>
                    &lt;div id=&quot;slider-thumb&quot; id=&quot;timeline-slider-thumb&quot;&gt;&lt;/div&gt;
                <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
            &lt;/input&gt;
            &lt;div id=&quot;volume-slider-container&quot;&gt;
                &lt;input type=&quot;range&quot; id=&quot;volume-slider&quot;&gt;
                    <span class=shadow-boundary>&lt;shadow-root id=&quot;volume-shadow-root&quot;&gt;</span>
                        &lt;div id=&quot;slider-thumb&quot; id=&quot;volume-slider-thumb&quot;&gt;&lt;/div&gt;
                    <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
                &lt;/input&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
&lt;/div&gt;
        </pre>

        <p>Let's have a user position their pointing device over the volume slider's thumb (<code>#volume-slider-thumb</code>), thus triggering a <code>mouseover</code> event on that node. For this event, let's pretend it has no associated <code>relatedTarget</code>.</p>

        <p>Per the <a>retargeting algorithm</a>, we should have the following set of ancestors and relative targets:</p>
        <table>
          <thead>
            <tr>
              <th>Ancestor</th>
              <th>Relative Target</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>#player</code></td>
              <td><code><strong>#player</strong></code></td>
            </tr>
            <tr>
              <td><code>#player-shadow-root</code></td>
              <td><code>#volume-slider</code></td>
            </tr>
            <tr>
              <td><code>#controls</code></td>
              <td><code>#volume-slider</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider-container</code></td>
              <td><code>#volume-slider</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider</code></td>
              <td><code><strong>#volume-slider</strong></code></td>
            </tr>
            <tr>
              <td><code>#volume-shadow-root</code></td>
              <td><code>#volume-slider-thumb</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider-thumb</code></td>
              <td><code><strong>#volume-slider-thumb</strong></code></td>
            </tr>
          </tbody>
        </table>

        <p>After we dispatch the <code>mouseover</code> event using these newly computed relative targets, the user decides to move their pointing device over the thumb of the timeline
          (<code>#timeline-slider-thumb</code>). This triggers both a <code>mouseout</code> event for the volume slider thumb and the <code>mouseover</code> event for the timeline thumb.</p>

        <p>Let's see how the <code>relatedTarget</code> value of the volume thumb's <code>mouseout</code> event is affected. For this event, the <code>relatedTarget</code> is the timeline thumb (<code>#timeline-slider-thumb</code>). Per the <a href="#retargeting-relatedtarget">relatedTarget retargeting</a>, we should have the following set of ancestors and adjusted related targets:</p>

        <table>
          <thead>
            <tr>
              <th>Ancestor</th>
              <th>Relative Target</th>
              <th>Adjusted related Target</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>#player</code></td>
              <td><code><strong>#player</strong></code></td>
              <td><code><strong>#player</strong></code></td>
            </tr>
            <tr>
              <td><code>#player-shadow-root</code></td>
              <td><code>#volume-slider</code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#controls</code></td>
              <td><code>#volume-slider</code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider-container</code></td>
              <td><code>#volume-slider</code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider</code></td>
              <td><code><strong>#volume-slider</strong></code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#volume-shadow-root</code></td>
              <td><code>#volume-slider-thumb</code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider-thumb</code></td>
              <td><code><strong>#volume-slider-thumb</strong></code></td>
              <td><code><strong>#timeline</strong></code></td>
            </tr>
          </tbody>
        </table>

        <p>The node, <code>#player</code>, has both <code>target</code> and <code>relatedTarget</code> being the same value (<code>#player</code>), which means that we do not dispatch the event on this <a>node</a> and its ancestors.</p>
      </section>

    </section>

    <section>
      <h2>User Interaction</h2>

      <section class="informative">
        <h3>Ranges and Selections</h3>

        <p>
          <a>Selection</a> [[!EDITING]] is not defined. Implementation should do their best to do what's best for them. Here's one possible, admittedly naive way:
        </p>

        <p>Since <a title="node">nodes</a> which are in the different <a title="node tree">node trees</a> never have the same <a>root</a>, there may never exist a valid <a title="range">DOM range</a> that spans multiple <a title="node tree">node trees</a>.</p>

        <p>Accordingly, <a title="selection">selections</a> may only exist within one <a>node tree</a>, because they are defined by a single <a>range</a>. The <a>selection</a>, returned by the <a><code>window.getSelection()</code></a> method never returns a <a>selection</a> within a <a>shadow tree</a>.</p>

        <p>The <code>getSelection()</code> method of the <a>shadow root</a> object returns the current <a>selection</a> in this <a>shadow tree</a>.</p>
      </section>

      <section>
        <h3>Focus Navigation</h3>

        <p>If a <a>node</a> doesn’t <a title="participates">participate</a> in the <a>composed tree</a>, the <a>node</a> <strong>must</strong> be skipped from the <a>navigation order</a> [[!CSS3UI]] sequence.</p>

        <p>For <a>sequential focus navigation</a>, the <a>navigation order</a> sequence for a given <a>shadow tree</a> <var>A</var> <strong>must</strong> be inserted into the <a>navigation order</a> for the <a>parent tree</a> <var>B</var> as follow:</p>
        <ol>
          <li>Let <var>HOST</var> be the <a>shadow host</a> which <a>hosts</a> A</li>
          <li>
            The <a>navigation order</a> for A <strong>must</strong> be inserted into the <a>navigation order</a> for <var>B</var>:
            <ol>
              <li>immediately after <var>HOST</var>, if <var>HOST</var> is <a>focusable</a>; or</li>
              <li>in place of the <var>HOST</var> as if <var>HOST</var> were assigned the value of <a title="nav-index auto"><code>auto</code></a> for determining its position.</li>
            </ol>
          </li>
        </ol>

        <p>For <a>directional focus navigation</a>, it is up to the user agent to integrate the <a title="navigation order">navigation orders</a> for <a title="shadow tree">shadow trees</a> into the <a>document</a> <a>navigation order</a>.</p>
      </section>

      <section>
        <h3>Active Element</h3>

        <p>To maintain encapsulation, the value of the <a title="Document object">Document</a> object's focus API property <a>activeElement</a> <strong>must</strong> be adjusted. To prevent loss of information when adjusting this value, each <a>shadow root</a> <strong>must</strong> also have an <code>activeElement</code> property to store the value of the focused <a>element</a> in the <a>shadow tree</a>.</p>

        <p>
          The <dfn>active element adjustment algorithm</dfn> <strong>must</strong> be used to determine the value of <a>activeElement</a> property, and it <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:
        </p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>ROOT</var>, either a <a>document</a> or a <a>shadow root</a></dd>
            <dd><var>ELEMENT</var>, the focused <a>element</a></dd>
            <dt>Output</dt>
            <dd><var>ADJUSTED</var>, an adjusted <a>activeElement</a> property of <var>ROOT</var>.</dd>
          </dl>
          <ol>
            <li>Let <var>ADJUSTED</var> be the result of the <a>retargeting algorithm</a> with <var>ROOT</var> and <var>ELEMENT</var> as input</li>
          </ol>
        </div>
      </section>

      <section>
        <h3>Editing</h3>

        <p>The value of the <a><code>contenteditable</code></a> attribute <strong>must not</strong> propagate from <a>shadow host</a> to its <a title="shadow tree">shadow trees</a>.</p>
      </section>

      <section>
        <h3>Assistive Technology</h3>

        <p>User agents with assistive technology traverse the <a>composed tree</a>, and thus enable full use of WAI-ARIA [[!WAI-ARIA]] semantics in the <a title="shadow tree">shadow trees</a>.</p>

      </section>

    </section>

    <section>
      <h2>HTML Elements in Shadow Trees</h2>

      <section>
        <h3>Inertness of HTML Elements in a shadow tree</h3>

        <p>Comparatively, a <a>shadow tree</a> can be seen as somewhere between <em>just part of a <a>document</a></em> and itself being a <a title="interface DocumentFragment">document fragment</a>. Since it is rendered, a <a>shadow tree</a> aims to retain the traits of a typical <a>tree</a> in a <a>document</a>. At the same time, it is an encapsulation abstraction, so it has to avoid affecting the <a>document tree</a>. Thus, the <a>HTML elements</a> <strong>must</strong> behave as specified [[!HTML]] in the <a title="shadow tree">shadow trees</a>, with a few exceptions.</p>

        <p class="note">
          According to the [[!HTML]], some HTML Elements would have different behavior if they participate in a <a>shadow tree</a>, instead of a document tree,
          because their definitions require the elements to be <a>in a document</a> as a necessary condition for them to work.
          In other words, they shouldn't work if they participate in a <a>shadow tree</a>, even when they are <a>in a document deeply</a>.
          We must fill this gap because we expect that most of HTML Elements behave in the same way as <a>in a document</a>, as long as they are <a>in a document deeply</a>.
          See W3C <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=26365">Bug 26365</a> and <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27406">Bug 27406</a> for the details.
          The following is the tentative summary of the discussions in the W3C bugs. We, however, haven't covered all HTML Elements and their behaviors here yet.
          For HTML Elements which are not explicitly stated here, they should be considered as <a>active in a shadow tree</a>.
          We are trying to update [[!HTML]] itself, instead of having monkey patches here.
        </p>
        <p>
          HTML Elements are classified into the following categories:
        </p>
        <ul>
          <li>
            <p>
              <dfn>Active in a shadow tree</dfn>
            </p>
            <p>
              A subset of <a>HTML elements</a> which <strong>must</strong> behave as if they were in the <a>document tree</a>, even when they participate in a <a>shadow tree</a>,
              as long as they are <a>in a document deeply</a>.
            </p>
            <p>
              The following HTML elements <strong>must</strong> be classified to this category:
            </p>
            <ul>
              <li><code>dialog</code></li>
              <li><code>iframe</code></li>
              <li><code>style</code></li>
            </ul>
          </li>
          <li>
            <p>
              <dfn>Inert in a shadow tree</dfn>:
            </p>
            <p>
              A subset of <a>HTML elements</a> which <strong>must</strong> behave as <a>inert</a>, or not part of the <a>document tree</a>, if they participate in a <a>shadow tree</a>.
              This is consistent how the <a>HTML elements</a> would behave in a <a title="interface DocumentFragment">document fragment</a>.
            </p>
            <p>
              The following HTML elements <strong>must</strong> be classified to this category:
            </p>
            <ul>
              <li><a title="base element"><code>base</code></a></li>
              <li><a title="link element"><code>link</code></a></li>
            </ul>
          </li>
          <li>
            <p>
              <dfn>Inert unless being rendered</dfn>:
            </p>
            <p>
              A subset of <a>HTML elements</a> which <strong>must</strong> behave as <a>inert</a>, or not part of the <a>document tree</a>,
              unless they are <a>being rendered</a>.
              In other words, if they don't particitpate in a <a>composed tree</a> whose root node is a document, they <strong>must</strong> behave as <a>inert</a>.
            </p>
            <p>
              The following HTML elements <strong>must</strong> be classified to this category:
            </p>
            <ul>
              <li><code>applet</code></li>
              <li><code>embed</code></li>
              <li><code>object</code></li>
            </ul>
            <p class="note">
              For example, suppose that an <code>object</code> element is a child node of a shadow host, but the <code>object</code> element's <a>destination insertion points</a> is empty.
              In this case, according to the <a>distribution algorithm</a> and <a>composed tree children calculation algorithm</a>,
              this element never participate in a <a>composed tree</a> whose root node is a <a>document</a>.
              Therefore, this element is <a>inert</a> because this element is not <a>being rendered</a>. .
            </p>
          </li>
        </ul>
      </section>

      <section>
        <h3>Attributes</h3>

        <p>When [[!HTML]] defines the processing algorithms to traverse trees for the following attributes, they <strong>must</strong> use the <a>composed tree</a>.
        <ul>
          <li><code>dir</code></li>
          <li><code>draggable</code></li>
          <li><code>dropzone</code></li>
          <li><code>hidden</code></li>
          <li><code>lang</code> and <code>xml:lang</code></li>
          <li><code>spellcheck</code></li>
          <li><code>title</code></li>
        </ul>

        <div class="note">
          <p>
            This list does not include attributes that are defined elsewhere in this specification. Such attributes include:
          </p>
          <ul>
            <li><code>tabindex</code> is defined in <a href="#focus-navigation">Focus Navigation</a>.</li>
            <li><code>role</code> and <code>ARIA</code> are defined in <a href="#assistive-technology">Assistive Technology</a>.</li>
          </ul>
        </div>
      </section>

    </section>

    <section>
      <h2>Elements and DOM interfaces</h2>

      <section>
        <h3>The <code>ShadowRoot</code> interface</h3>

        <p>The <code>ShadowRoot</code> interface represents the <a>shadow root</a>.</p>

        <dl class="idl" title="interface ShadowRoot : DocumentFragment">
          <dt>Selection? getSelection()</dt>
          <dd>
            <p>Returns the current selection in the <a>shadow tree</a>.</p>
            <p>When invoked, it <strong>must</strong> return the <a>selection</a> in the <a>shadow tree</a>.</p>
          </dd>

          <dt>Element? elementFromPoint(double x, double y)</dt>
          <dd>
            <p>Returns an <a>element</a> at specified coordinates.</p>
            <p class="note">
              Eventually, this needs to be part of CSSOM View Module specification [[!CSSOM-VIEW]]. See also <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27829">W3C bug 27829</a>.
            </p>
            <p>
              When invoked, it <strong>must</strong> return result of running the following steps:
            </p>
            <ol>
              <li>If <a>context object</a> is not a <a><code>ShadowRoot</code></a> instance, throw an <a><code>InvalidNodeTypeError</code></a>.</li>
              <li>If either argument is negative, <code>x</code> is greater than the <a>viewport</a> width excluding the size of a rendered scroll bar (if any), or if <code>y</code> is greater than the <a>viewport</a> height excluding the size of a rendered scroll bar (if any), return <strong>null</strong>.</li>
              <li>Let <var>HIT</var> be the <a>element</a> at coordinates <code>x</code> and <code>y</code> in the <a>viewport</a>, determined through hit testing</li>
              <li>Let <var>PATH</var> be the result of running the <a>event path calculation algorithm</a> with <var>HIT</var> and null as input</li>
              <li>Return the result of running the <a>retargeting algorithm</a> with <var>PATH</var> and <a>context object</a> as input</li>
            </ol>
          </dd>

          <dt>sequence&lt;Element&gt; elementsFromPoint(double x, double y)</dt>
          <dd>
            <p class="note">
              It could be defined in roughly the same way as <a>elementFromPoint</a>.
              Eventually, this needs to be part of CSSOM View Module specification [[!CSSOM-VIEW]]. See also <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27829">W3C bug 27829</a>.
            </p>
          </dd>

          <dt>CaretPosition? caretPositionFromPoint(double x, double y)</dt>
          <dd>
            <p class="note">
              It could be defined in roughly the same way as <a>caretPositionFromPoint</a> [[!CSSOM-VIEW]].
              Eventually, this needs to be part of CSSOM View Module specification [[!CSSOM-VIEW]]. See also <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27829">W3C bug 27829</a>.
          </dd>

          <dt>readonly attribute Element? activeElement</dt>
          <dd>
            <p>Represents the currently focused <a>element</a> in the <a>shadow tree</a>.</p>
            <p>On getting, the attribute <strong>must</strong> return the currently focused <a>element</a> in the <a>shadow tree</a> or <code>null</code>, if there is none.</p>
          </dd>

          <dt>readonly attribute Element host</dt>
          <dd>
            <p>Represents the <a>shadow host</a> which <a>hosts</a> the <a>context object</a>.</p>
            <p>On getting, the attribute <strong>must</strong> return the <a>shadow host</a> which <a>hosts</a> the <a>context object</a>.</p>
          </dd>

          <dt>[TreatNullAs=EmptyString] attribute DOMString innerHTML</dt>
          <dd>
            <p>Represents the markup of <a><code>ShadowRoot</code></a>'s contents.</p>
            <p>On getting, the attribute <strong>must</strong> return the result of running the <a>HTML fragment serialization algorithm</a> with the <a>context object</a> as <a title="shadow host"><code>shadow host</code></a>.</p>
            <p>
              On setting, these steps <strong>must</strong> be run:
            </p>
            <ol>
              <li>Let <var>FRAGMENT</var> be the result of invoking the <a title="parse fragment">fragment parsing algorithm</a> [[!DOM-PARSING]] with the new value as <var>MARKUP</var>, and the <a>context object</a> as <a title="shadow host"><code>shadow host</code></a></li>
              <li><a>Replace all</a> with <var>FRAGMENT</var> within the <a>shadow root</a>.</li>
            </ol>
          </dd>

          <dt>readonly attribute StyleSheetList styleSheets</dt>
          <dd>
            <p>Represents the <a>shadow root style sheets</a>.</p>
            <p>On getting, the attribute <strong>must</strong> return a <a><code>StyleSheetList</code></a> sequence containing the <a>shadow root style sheets</a>.
            </p>
          </dd>
        </dl>

        <p>The <a><code>nodeType</code></a> attribute of a <a><code>ShadowRoot</code></a> instance <strong>must</strong> return <a><code>DOCUMENT_FRAGMENT_NODE</code></a>. Accordingly, the <a><code>nodeName</code></a> attribute of a <a><code>ShadowRoot</code></a> instance <strong>must</strong> return <code>"#document-fragment"</code>.</p>

        <p>Invoking the <a><code>cloneNode()</code></a> method on a <a><code>ShadowRoot</code></a> instance <strong>must</strong> always throw a <a><code>DATA_CLONE_ERR</code></a> exception.</p>

      </section>

      <section>
        <h3>Extensions to <code>Element</code> Interface</h3>

        <dl class="idl" title="partial interface Element">
          <dt>ShadowRoot createShadowRoot(ShadowRootInit shadowRootInitDict)</dt>
          <dd>
            When invoked, these steps <strong>must</strong> be run:
            <ol>
              <li>If the <a>context object</a> is an element which has a <a>binding</a> property, throws <code>NotSupportedError</code> exception.</li>
              <li>If the <a>context object</a> already hosts the shadow tree, throws <code>InvalidStateError</code> exception.</li>
              <li>
                Create a new instance of the <a><code>ShadowRoot</code></a> object.
                The <code>shadowRootInitDict</code> argument allows for setting the <a>encapsulation mode</a>.
              </li>
              <li>Let the <a>content object</a> host the <a><code>ShadowRoot</code></a> object.</li>
              <li>Return <a><code>ShadowRoot</code></a> object.</li>
            </ol>
          </dd>

          <dt>NodeList getDestinationInsertionPoints()</dt>
          <dd>
            When invoked, the method <strong>must</strong> return a <a>static</a> <a><code>NodeList</code></a> consisting of <a title="unclosed node" >unclosed</a> <a title="insertion point">insertion points</a> of <a>the context object</a> in the <a>destination insertion points</a> of the <a>context object</a>.
          </dd>
          <dt>readonly attribute ShadowRoot? shadowRoot</dt>
          <dd>
            <p>Represents the <a>shadow root</a> that <a>context object</a> <a>hosts</a>.</p>
            <p>On getting, the attribute <strong>must</strong> return the <a>shadow root</a> that <a>context object</a> <a>hosts</a> if there is and it is <a>open</a>. Otherwise <strong>must</strong> return <code>null</code>.</p>
          </dd>
        </dl>
      </section>

      <section>
        <h3><code>ShadowRootInit</code> dictionary</h3>
        <dl class="idl" title="dictionary ShadowRootInit">
          <dt>ShadowRootMode mode</dt>
          <dd>Specifies the <a>encapsulation mode</a> of <a>ShadowRoot</a></dd>
        </dl>
      </section>

      <section>
        <h3><code>ShadowRootMode</code> enum</h3>
        <dl class="idl" title="enum ShadowRootMode">
          <dt>open</dt>
          <dd>Specifies <a>open</a> <a>encapsulation mode</a></dd>
          <dt>closed</dt>
          <dd>Specifies <a>closed</a> <a>encapsulation mode</a></dd>
        </dl>
      </section>

      <section>
        <h3>Extensions to <code>Text</code> Interface</h3>

        <dl class="idl" title="partial interface Text">
          <dt>NodeList getDestinationInsertionPoints()</dt>
          <dd>When invoked, the method <strong>must</strong> return a <a>static</a> <a><code>NodeList</code></a> consisting of <a title="insertion point">insertion points</a> in the <a>destination insertion points</a> of the <a>context object</a>, excluding an <a>insertion point</a> which participates in a <a>closed</a> shadow tree.</dd>
        </dl>
      </section>

      <section>
        <h3>The <code>content</code> element</h3>

        <p>The <code><dfn title="content element">content</dfn></code> element represents an <a>insertion point</a> in the <a>shadow tree</a>.</p>

        <p>If a <code>content</code> element does not satisfy the condition of an <a>insertion point</a>, it <strong>must</strong> have the same rendering behavior as the <a><code>HTMLUnknownElement</code></a>.</p>

        <dl>
          <dt>Context</dt>
          <dd>Where <a>flow content</a> is expected.</dd>

          <dt>Content model</dt>
          <dd><a>Transparent</a></dd>

          <dt>Children</dt>
          <dd>Anything as fallback content</dd>

          <dt>Content attributes</dt>
          <dd><a>Global attributes</a></dd>
          <dd>
            <dl>
              <dt><code><dfn title="content element select">select</dfn></code>, a <a title="comma separated tokens">set of comma-separated tokens</a></dt>
              <dd>Represents the <a>matching criteria</a> for <a title="distribution">distributing</a> child <a title="node">nodes</a> of the <a>shadow host</a>. Each token <strong>must</strong> be a <a>compound selector</a>.</dd>
            </dl>
          </dd>

          <dt>DOM Interface</dt>
          <dd>
            <dl class="idl" title="interface HTMLContentElement : HTMLElement">
              <dt>attribute DOMString select</dt>
              <dd><strong>Must</strong> <a>reflect</a> the <a title="content element select">select</a> attribute.</dd>

              <dt>sequence&lt;Node&gt; getDistributedNodes()</dt>
              <dd>
                When invoked, it <strong>must</strong> return result of running the following steps:
                <ol>
                  <li>
                    If the <a>context object</a> is a <a>content insertion point</a>:
                    <ol>
                      <li>
                        Return a <a>sequence</a> consisting of nodes in the <a>distributed nodes</a> of the <a>context object</a>.
                      </li>
                    </ol>
                  </li>
                  <li>
                    Otherwise:
                    <ol>
                      <li>Return an empty <a>sequence</a>.</li>
                    </ol>
                  </li>
                </ol>
              </dd>
            </dl>
          </dd>
        </dl>
      </section>

      <section>
        <h3>Extensions to <a><code>EventInit</code></a> Dictionary</h3>

        <dl class="idl" title="partial dictionary EventInit">
          <dt>boolean scoped = false</dt>
          <dd>
            <p>Specifies the <a>scoped flag</a> of <code>Event</code></p>
          </dd>
        </dl>
      </section>

      <section>
        <h3>Extensions to <code>Event</code> Interface</h3>

        <dl class="idl" title="partial interface Event">
          <dt>readonly attribute object deepPath</dt>
          <dd>
            <p>Represents the event path.</p>
            <p>
              On getting, the attribute <strong>must</strong> create and return a new JavaScript Array object,
              that <strong>must</strong> be equivalent to processing the following steps:
            </p>

            <div class="algorithm">
              <dl>
                <dt>Input</dt>
                <dd><var>EVENT</var>, a <a>context object</a></dd>
                <dt>Output</dt>
                <dd><var>PATH</var>, an array of nodes</dd>
              </dl>

              <ol>
                <li>If <var>EVENT</var> hasn't been dispatched, return a new empty array.</li>
                <li>
                  Otherwise:
                  <ol>
                    <li>Let <var>PATH</var> be the event path of <var>EVENT</var>.</li>
                    <li>
                      If <var>EVENT</var> is being dispatched:
                      <ol>
                        <li>Let <var>CURRENT-TARGET</var> be the <a>current target</a> of <var>EVENT</var>.</li>
                      </ol>
                    </li>
                    <li>
                      Otherwise:
                      <ol>
                        <li>Let <var>CURRENT-TARGET</var> be the last node of <var>PATH</var>.</li>
                      </ol>
                    </li>
                    <li>Let PATH contain only a node which is an <a>unclosed node</a> of <var>CURRENT-TARGET</var>.</li>
                  </ol>
                </li>
              </ol>
            </div>

            <p class="issue">
              The API is not stable and may change. Use <code>FrozenArray</code> as the return type of the <code>deepPath</code> attribute in WebIDL.
              See <a href="https://github.com/w3c/webcomponents/issues/101">Issue #101</a>
            </p>
          </dd>
          <dt>readonly attribute boolean scoped</dt>
          <dd>
            <p>
              Returns the <dfn>scoped flag</dfn>.
            </p>
          </dd>
        </dl>
      </section>

    </section>

    <section>
      <h2>Shadow DOM Example</h2>

      <p>Bob was asked to turn a simple list of links into a News Widget, which has links organized into two categories: breaking news and just news. The current document markup for the stories looks like this:</p>
      <pre class="example highlight">
&lt;ul class=&quot;stories&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/1&quot;&gt;A story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/2&quot;&gt;Another story&lt;/a&gt;&lt;/li&gt;
    &lt;li class=&quot;breaking&quot;&gt;&lt;a href=&quot;//example.com/stories/3&quot;&gt;Also a story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/4&quot;&gt;Yet another story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/4&quot;&gt;Awesome story&lt;/a&gt;&lt;/li&gt;
    &lt;li class=&quot;breaking&quot;&gt;&lt;a href=&quot;//example.com/stories/5&quot;&gt;Horrible story&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      </pre>

      <p>To organize the stories, Bob decides to use <strong>shadow DOM</strong>. Doing so will allow Bob to keep the document markup uncluttered, and harnessing the power of insertion point makes sorting stories by class name a very simple task. After getting another cup of <a href="http://en.wikipedia.org/wiki/List_of_coffee_beverages#Green_Eye">Green Eye</a>, he quickly mocks up the following shadow tree, to be hosted by the <code>ul</code> element:</p>
      <pre class="example highlight">
&lt;div class=&quot;breaking&quot;&gt;
    &lt;ul&gt;
        &lt;content select=&quot;.breaking&quot;&gt;&lt;/content&gt; &lt;!-- insertion point for breaking news --&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;other&quot;&gt;
    &lt;ul&gt;
        &lt;content&gt;&lt;/content&gt; &lt;!-- insertion point for the rest of the news --&gt;
    &lt;/ul&gt;
&lt;/div&gt;
      </pre>
      <p>Bob then styles the newborn widget according to comps from the designer by adding this to the shadow tree mockup:</p>
      <pre class="example highlight">
&lt;style&gt;
    div.breaking {
        color: Red;
        font-size: 20px;
        border: 1px dashed Purple;
    }
    div.other {
        padding: 2px 0 0 0;
        border: 1px solid Cyan;
    }
&lt;/style&gt;
      </pre>
      <p>While pondering if his company should start looking for a new designer, Bob converts the mockup to code:</p>
      <pre class="example highlight">
function createStoryGroup(className, contentSelector)
{
    var group = document.createElement('div');
    group.className = className;
    // Empty string in select attribute or absence thereof work the same, so no need for special handling.
    group.innerHTML = '&lt;ul&gt;&lt;content select=&quot;' + contentSelector + '&quot;&gt;&lt;/content&gt;&lt;/ul&gt;';
    return group;
}

function createStyle()
{
    var style = document.createElement('style');
    style.textContent = 'div.breaking { color: Red;font-size: 20px; border: 1px dashed Purple; }' +
        'div.other { padding: 2px 0 0 0; border: 1px solid Cyan; }';
    return style;
}

function makeShadowTree(storyList)
{
    var root = storyList.createShadowRoot({mode: 'open'});
    root.appendChild(createStyle());
    root.appendChild(createStoryGroup('breaking', '.breaking'));
    root.appendChild(createStoryGroup('other', ''));
}

document.addEventListener('DOMContentLoaded', function() {
    [].forEach.call(document.querySelectorAll('ul.stories'), makeShadowTree);
});
      </pre>

      <p>Well done, Bob! With the cup of coffee still half-full, the work is complete. Recognizing his awesomeness, Bob returns to teaching n00bs the ways of <a href="http://en.wikipedia.org/wiki/Puyo_Puyo_(series)">Puyo Puyo</a>.</p>

      <p>A few months pass.</p>

      <p>It's election time. With Bob at his annual conference, Alice is charged with adding <strong>another</strong>, temporary box to the news widget, filled with election-related stories. Alice studies Bob's code, reads up on the shadow DOM spec and realizes that, thanks to multiple shadow tree support, she doesn't have to touch his code. As usual, her solution is elegant and simple, fitting neatly right under Bob's code:</p>
      <pre class="example highlight">
// TODO(alice): BEGIN -- DELETE THIS CODE AFTER ELECTIONS ARE OVER.
var ELECTION_BOX_REMOVAL_DEADLINE = ...;

function createElectionStyle()
{
    var style = document.createElement('style');
    // TODO(alice): Check designer's desk for hallucinogens.
    style.textContent = 'div.election { color: Magenta; font-size: 24px; border: 2px dotted Fuchsia; }';
    return style;
}

function makeElectionShadowTree(storyList)
{
    var root = storyList.createShadowRoot({mode: 'open'});
    // Add and style election story box.
    root.appendChild(createElectionStyle());
    root.appendChild(createStoryGroup('election', '.election'));
    // Insert Bob's shadow tree under the election story box.
    root.appendChild(document.createElement('shadow'));
}

if (Date.now() &lt; ELECTION_BOX_REMOVAL_DEADLINE) {
    document.addEventListener('DOMContentLoaded', function() {
        [].forEach.call(document.querySelectorAll('ul.stories'), makeElectionShadowTree);
    });
}
// TODO(alice): END -- DELETE THIS CODE AFTER ELECTIONS ARE OVER.
      </pre>
      <p>Using the <code>shadow</code> element allows Alice to compose Bob's widget <strong>inside</strong> of hers&mdash;without having to change a line of production code. Smiling to herself, Alice realizes that Bob may have come up with a way to keep the document markup clean, but <strong>she</strong> is the one who takes the cake for using shadow tree composition in such a cool way.</p>
    </section>

    <section class="appendix">
      <h2>Acknowledgements</h2>

      <p><span class="vcard">David Hyatt</span> developed <a href="http://dev.w3.org/2006/xbl2/">XBL 1.0</a>, and <span class="vcard">Ian Hickson</span> co-wrote <a href="http://dev.w3.org/2006/xbl2/">XBL 2.0</a>. These documents provided tremendous insight into the problem of functional encapsulation and greatly influenced this specification.</p>

      <p><span class="vcard">Alex Russell</span> and his considerable forethought triggered a new wave of enthusiasm around the subject of shadow DOM and how it can be applied practically on the Web.</p>

      <p><span class="vcard">Dominic Cooney</span>, <span class="vcard">Hajime Morrita</span>, and <span class="vcard">Roland Steiner</span> worked tirelessly to scope the problem of functional encapsulation within the confines of the Web platform and provided a solid foundation for this document.</p>

      <p>The editor would also like to thank <span class="vcard">Alex Komoroske</span>, <span class="vcard">Anne van Kesteren</span>, <span class="vcard">Brandon Payton</span>, <span class="vcard">Brian Kardell</span>, <span class="vcard">Darin Fisher</span>, <span class="vcard">Eric Bidelman</span>, <span class="vcard">Deepak Sherveghar</span>, <span class="vcard">Edward O'Connor</span>, <span class="vcard">Elisée Maurer</span>, <span class="vcard">Elliott Sprehn</span>, <span class="vcard">Erik Arvidsson</span>, <span class="vcard">Glenn Adams</span>, <span class="vcard">Jonas Sicking</span>, <span class="vcard">Koji Ishii</span>, <span class="vcard">Malte Ubl</span>, <span class="vcard">Mike Taylor</span>, <span class="vcard">Oliver Nightingale</span>, <span class="vcard">Olli Pettay</span>, <span class="vcard">Rafael Weinstein</span>, <span class="vcard">Richard Bradshaw</span>, <span class="vcard">Ruud Steltenpool</span>, <span class="vcard">Sam Dutton</span>, <span class="vcard">Sergey G. Grekhov</span>, <span class="vcard">Shinya Kawanaka</span>, <span class="vcard">Tab Atkins</span>, <span class="vcard">Takashi Sakamoto</span>, and <span class="vcard">Yoshinori Sano</span> for their comments and contributions to this specification.</p>

      <p>This list is too short. There's a lot of work left to do. Please contribute by reviewing and filing bugs&mdash;and don't forget to ask the editor to add your name into this section.</p>
    </section>

  </body>
</html>
