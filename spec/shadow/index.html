<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'/>
    <title>Shadow DOM</title>
    <script src='./autolink-config.js' class='remove'></script>
    <script src='../../assets/scripts/autolink.js' class='remove'></script>
    <link rel="stylesheet" href="../../assets/styles/respec-complement.css" type="text/css" />
    <script src='//www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script src='//resources.whatwg.org/dfn.js' defer class='remove'></script>
    <script class='remove'>
      function resolveBacklink() {
          // For dfn.js
          if (window.initDfn) {
              initDfn();
          }
      }
      var respecConfig = {
          specStatus: "ED",
          shortName: "shadow-dom",
          useExperimentalStyles: true,
          editors: [{ name: "Hayato Ito", url: "mailto:hayato@google.com", company: "Google, Inc.", w3cid: 49814 }],
          wg: "Web Platform Working Group",
          wgURI: "http://www.w3.org/WebPlatform/WG/",
          wgPublicList: "public-webapps",
          wgPatentURI: "http://www.w3.org/2004/01/pp-impl/83482/status",
          license: "w3c-software-doc",
          edDraftURI: "http://w3c.github.io/webcomponents/spec/shadow/",
          otherLinks: [
              {
                  key: "Revision history",
                  href: "https://github.com/w3c/webcomponents/commits/gh-pages/spec/shadow/"
              },
              {
                  key: "Bugs filed",
                  href: "https://github.com/w3c/webcomponents/labels/shadow-dom"
              }
          ],
          preProcess: [resolveAutolink],
          postProcess: [resolveBacklink],
          localBiblio: {
              "EDITING": {
                  title: "HTML Editing APIs",
                  href: "https://dvcs.w3.org/hg/editing/raw-file/tip/editing.html",
                  authors:  ["Aryeh Gregor"]
              }
          }
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This specification describes a method of combining multiple DOM trees into one hierarchy and how these trees interact with each other within a document, thus
        enabling better composition of the DOM.
      </p>
    </section>

    <section id='sotd'>
    </section>

    <section>
      <h2>Conformance</h2>

      <p>All diagrams, examples, notes, are non-normative, as well as sections explicitly marked as non-normative. Everything else in this specification is normative.</p>

      <p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this document are to be interpreted as described in [[!RFC2119]]. For readability, these words do not appear in all uppercase letters in this specification.</p>

      <p>To help with layering and to avoid circular dependencies between various parts of specification, this document consists of three consecutive narratives:</p>
      <ol>
        <li>setting up the stage for the specification,</li>
        <li>explaining of the conceptual model and algorithms behind it, and</li>
        <li>expressing this model with DOM interfaces and HTML elements.</li>
      </ol>

      <p>In a sense, these parts can be viewed as <em>math</em>, which sets up the reasoning environment, <em>physics</em>, which is the theoretical reasoning about the concept, and <em>mechanics</em>, which is the practical application of this reasoning.</p>

      <p>Any point, at which a conforming UA must make decisions about the state or reaction to the state of the conceptual model, is captured as <a href="http://en.wikipedia.org/wiki/Algorithm">algorithm</a>. The algorithms are defined in terms of processing equivalence. The <dfn>processing equivalence</dfn> is a constraint imposed on the algorithm implementors, requiring the output of the both UA-implemented and the specified algorithm to be exactly the same for all inputs.</p>
    </section>

    <section>
      <h2>Composition</h2>

      <section>
        <h3>Shadow trees</h3>

        <p class="note">
          Shadow DOM specification is being upstreamed to DOM Standard [[!WHATWG-DOM]]. Most of the concepts about shadow trees are now being defined in DOM Standard.
        </p>

        <p>
          An element <var>A</var> is a <dfn>shadow host</dfn> if <var>A</var> is a <a>host</a> that is associated with a <a>shadow root</a> <var>B</var>.
          In this case, <var>A</var> <dfn>hosts</dfn> a <a>shadow tree</a> whose <a>root</a> is <var>B</var>.
        </p>

        <p>
          A node <var>A</var> is called a <dfn>shadow-including child</dfn> of a node <var>B</var>,
          if <var>A</var> is a child of <var>B</var>, or <var>A</var> is a <a>shadow root</a> and <var>B</var> is the <a>host</a> of <var>A</var>.
        </p>

        <p>
          A node <var>A</var> is called a <dfn>shadow-including parent</dfn> of a node <var>B</var>,
          if <var>B</var> is a <a>shadow-including child</a> of <var>A</var>.
        </p>

        <p>
          A node <var>A</var> is called a <dfn>shadow-including ancestor</dfn> of a node <var>B</var>
          if <var>B</var> is a <a>shadow-including descendant</a> of <var>A</var>.
        </p>

        <p>
          An <dfn>shadow-including inclusive ancestor</dfn> is a node or one of its <a data-lt="shadow-including ancestor">shadow-including ancestors</a>.
        </p>

      </section>

      <section>
        <h3>Composed trees</h3>

        <p>A <dfn>composed tree of node trees</dfn> is a <a>tree</a> of <a data-lt="node tree">node trees</a>.</p>

        <p class="note">
          The purpose of introducing a composed tree of node trees here is to define algorithms easily in the following sections.
          This is a kind of a notation techchique to make the this specification simpler.
        </p>

        <p>Just like a <a>node tree</a> is defined as <a data-lt="tree">a set of relationships</a> between <a data-lt="node">nodes</a>,
          a <a>composed tree of node trees</a> is similarly defined as a set of relationships between node trees:</p>
        <ul>
          <li>
            A <a>node tree</a> <var>A</var> is called a <dfn>parent tree</dfn> of a <a>node tree</a> <var>B</var> if B is a shadow tree and the shadow host which hosts <var>B</var> participates in <var>A</var>.
          </li>
          <li>
            A <a>node tree</a> <var>A</var> is called a <dfn>preceding sibling tree</dfn> of a <a>node tree</a> <var>B</var> if all of the following conditions are satisfied:
            <ol>
              <li><var>A</var> and <var>B</var> share the same <a>parent tree</a>.</li>
              <li>The <a>shadow host</a> which <a>hosts</a> <var>A</var> is <a>preceding</a> the <a>shadow host</a> which <a>hosts</a> <var>B</var>.</li>
            </ol>
          </li>
          <li>Other relationships and terms, such as <dfn>root tree</dfn>, <dfn>child tree</dfn>,
            <dfn>descendant tree</dfn>, <dfn>inclusive descendant tree</dfn>,
            <dfn>ancestor tree</dfn>, <dfn>inclusive ancestor tree</dfn>,
            <dfn>preceding tree</dfn>
            are defined in the similar way as defined in <a data-lt="tree">trees</a>.</li>
        </ul>

        <p>
          A <a>node tree</a> <var>A</var> is called an <dfn>unclosed tree</dfn> of a <a>node tree</a> <var>B</var> if and only if one, at least, of the following conditions is satisfied:
        </p>

        <ul>
          <li><var>A</var> is an <a>inclusive ancestor tree</a> of <var>B</var>.</li>
          <li><var>A</var> is a <a>child tree</a> of <var>B</var> and <var>A</var>'s <a>root</a>'s <a>mode</a> is "open".</li>
          <li><var>A</var> is an <a>unclosed tree</a> of a <a>node tree</a> <var>C</var> that is an <a>unclosed tree</a> of <var>B</var>.</li>
        </ul>

        <p>
          A node <var>A</var> is called an <dfn>unclosed node</dfn> of a node <var>B</var> if and only if the <a>node tree</a> that <var>A</var> <a>participates</a> in
          is an <a>unclosed tree</a> of the <a>node tree</a> that <var>B</var> <a>participates</a> in.
        </p>

        <p>
          A <dfn>composed document</dfn> is a <a>composed tree of node trees</a> whose <a>root tree</a> is a <a>document tree</a>.
        </p>

        <p><a><code>Window</code></a> object <a data-lt="named access on the window object">named properties</a> [[!HTML]] <strong>must</strong> access the <a data-lt="node">nodes</a> in the <a>document tree</a>.</p>

        <section class="informative">
          <h3>Example composed tree of node trees</h3>

          <figure>
            <object data="../../assets/images/composed-tree.svg" width="650" height="823"></object>
            <figcaption>
              A composed tree of node trees.
            </figcaption>
          </figure>

          <p>
            In the figure, there are six node trees, named <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code> and <code>F</code>.
            The shadow trees, <code>B</code>, <code>C</code> and <code>D</code>, are hosted by elements which participate in the document tree <code>A</code>.
            The shadow trees, <code>E</code> and <code>F</code>, are hosted by elements which participates in the shadow tree <code>D</code>.
            The following set of relationships holds in the figure:
          </p>
          <ul>
            <li>The ordered list of <code>A</code>'s <a data-lt="child tree">child trees</a> is [<code>B</code>, <code>C</code>, <code>D</code>].</li>
            <li>The ordered list of <code>B</code>'s <a data-lt="child tree">child trees</a> is [].</li>
            <li>The ordered list of <code>C</code>'s <a data-lt="child tree">child trees</a> is [].</li>
            <li>The ordered list of <code>D</code>'s <a data-lt="child tree">child trees</a> is [<code>E</code>, <code>F</code>].</li>
            <li>The ordered list of <code>E</code>'s <a data-lt="child tree">child trees</a> is [].</li>
            <li>The ordered list of <code>F</code>'s <a data-lt="child tree">child trees</a> is [].</li>
            <li>The document tree, <code>A</code>, is the <a>root tree</a> of the <a>composed tree of node trees</a>.</li>
          </ul>

          <div class="note">
            <p>
              As for a relationship between nodes, it's worth mentioning that there is no <a>ancestor</a>/<a>descendant</a> relationships between two nodes if they participate in different node trees.
              A shadow root is not a <a>child</a> node of the shadow host. The <a>parent</a> node of a <a>shadow root</a> doesn't exist.
              Because of this nature, most of existing APIs are <strong>scoped</strong> and don't affect other node trees, even though they are forming one composed tree of node trees.
              For example, <a data-lt="getElementById"><code>document.getElementById(elementId)</code></a> never returns an element in a shadow tree,
              even when the element has the given <code>elementId</code>.
            </p>
            <p>
              The same thing also applies to CSS <a data-lt="selectors">Selectors</a> matching.
              For example, a <a data-lt="descendant combinators">descendant combinator</a> never descends into a node in a <a data-lt="child tree">child</a> <a>shadow tree</a>
              because a <a>shadow root</a> is not a <a>child</a> node of the <a>shadow host</a>.
              Unless a special CSS Selector for Shadow DOM, which is mentioned later, is used, a CSS Selector never matches an element in a different node tree.
            </p>
          </div>
          <p class="note">
            Because <code>ShadowRoot</code> inherits <code>DocumentFragment</code>, as <a href="#idl-def-ShadowRoot">specified</a> later,
            you can use <code>ShadowRoot.getElementByID(elementId)</code> to get a node in the <a>shadow tree</a>.
          </p>

          <ul class="note">
            <li>
              A <a>document tree</a> is always the <a>root tree</a> of a <a>composed tree of node trees</a>.
            </li>
            <li>
              A <a>shadow tree</a> is never the <a>root tree</a> of a <a>composed tree of node trees</a>. It always has a <a>parent tree</a>.
            </li>
            <li>
              A <a>root tree</a> of a <a>composed tree of node trees</a> is not always a <a>document tree</a>.
              For example, a <a>node tree</a> whose <a>root</a> is <code>DocumentFragment</code>, but which is not a <a>shadow root</a>, is the <a>root tree</a> of a <a>composed tree of node trees</a>.
            </li>
            <li>
              The algorithms described in the following sections are applied even if the <a>root tree</a> of a <a>composed tree of node trees</a> is not a <a>document tree</a>.
              In other words, Shadow DOM doesn't care what the <a>root tree</a> is for any particular feature to work or not work.
            </li>
          </ul>

        </section>

      </section>

      <section>
        <h3>Flat trees</h3>

        <p>A <dfn>flat tree</dfn> is a <a>node tree</a> which is constructed out of <a data-lt="node">nodes</a> from multiple <a data-lt="node tree">node trees</a> in a <a>composed tree of node trees</a>.
          The exact algorithm of constructing a flat tree is specified later.</p>

        <figure>
          <object data="../../assets/images/flat-tree.svg" width="654" height="606"></object>
          <figcaption>A flat tree</figcaption>
        </figure>

        <p>A <dfn>document flat tree</dfn> is a <a>flat tree</a> whose root node is a document</p>

        <p>A node is <dfn>in a document flat tree</dfn> if it participates in a <a>document flat tree</a>.</p>

        <p>
          Unless an element is <a>in a document flat tree</a>, the element <strong>must not</strong> create any CSS <a>box</a>.
        </p>
        <p>
          In resolving CSS <a>inheritance</a>, an element <strong>must</strong> inherit from the parent node in the <a>flat tree</a>, if applicable.
        </p>
        <p>
          User agents <strong>must</strong> use the <a>document flat tree</a> in the <a>visual formatting model</a>, instead of the <a>document tree</a>.
        </p>

        <div class="note">
          <p>
            The editor's draft of CSS Scoping specification [[css-scoping-1]] defines the selectors which are related to Shadow DOM.
            Specifically, it defines the following selectors related to Shadow DOM:
          </p>

          <ul>
            <li><code>::shadow</code> pseudo element</li>
            <li><code>/deep/</code> combinator,  which was replaced with a <code>>>></code> combinator (or <strong>shadow piercing descendant combinator</strong>)</li>
            <li><code>::content</code> pseudo-element</li>
            <li><code>:host</code> pseudo-class and <code>:host()</code> functional pseudo-class</li>
            <li><code>:host-context()</code> functional pseudo-class</li>
          </ul>
        </div>
      </section>

    </section>

    <section>
      <h2>Distributions</h2>

      <section>
        <h3>Slots</h3>

        <p>
          The <a>slot element</a> represents an <em>instruction element</em>, called <dfn>slot</dfn>.
          When constructing a <a>flat tree</a>, a <a>slot</a> does not participate in the flat tree. Instead, the <a>slot</a> cherry-picks its contents from other places in the composed tree of node trees.
          The exact algorithm of constructing a <a>flat tree</a> is specified later.
        </p>

        <p class="note">
          A slot usually cherry-picks its contents from the shadow host.
        </p>

        <p>
          A node can be <dfn>assigned</dfn> to a slot, called an <dfn>assigned slot</dfn>. The exact algorithm of determining the <a>assigned slot</a> for a node is specified later.
        </p>

        <p>
          A node is called <dfn>slot assignable</dfn> if it is either <code>Text</code> or <code>Element</code>.
        </p>

        <p>A <dfn>distribution</dfn> is the mechanism that determines which <a data-lt="node">nodes</a> appear at each <a>slot</a>. The exact algorithm of a <a>distribution</a> is specified later.</p>

        <figure>
          <object data="../../assets/images/distribution.svg" width="663" height="598"></object>
          <figcaption>A distribution</figcaption>
        </figure>


        <p>
          A <dfn>slot name</dfn> is the name of a <a>slot</a>.
        </p>

        <p>
          A <dfn>default slot</dfn> is the first <a>slot</a> element, in tree order, in a <a>node tree</a>, whose <a>slot name</a> is the empty string or missing.
        </p>

      </section>

      <section>
        <h2>Slotting Algorithm</h2>

        <p>
          The <dfn>slotting algorithm</dfn> <strong>must</strong> be used to determine the <a>assigned slot</a> of each node and <strong>must</strong> be <a data-lt="processing equivalence">equivalent</a> to processing the following steps:
        </p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>NODE</var>, a node</dd>
            <dt>Output</dt>
            <dd>(nullable) <var>SLOT</var>, a <var>slot</var> to which <var>NODE</var> is assigned.</dd>
          </dl>

          <ol>
            <li>
              If <var>NODE</var> is <a>slot assignable</a> and the parent node of <var>NODE</var> is a <a>shadow host</a>:
              <ol>
                <li>Let <var>TREE</var> be the <a>shadow tree</a> that the parent node of <var>NODE</var> <a>hosts</a></li>
                <li>Let <var>NAME</var> be the value of the <a href="#widl-Element-slot">slot attribute</a> of <var>NODE</var></li>
                <li>
                  If <var>NAME</var> is the empty string or missing:
                  <ol>
                    <li>Let <var>SLOT</var> be a <a>default slot</a> for <var>TREE</var> if it exists, Otherwise, null</li>
                  </ol>
                </li>
                <li>
                  Otherwise:
                  <ol>
                    <li>Let <var>SLOT</var> be the first <a>slot</a> element, in tree order, in <var>TREE</var>, whose <a>slot name</a> is <var>NAME</var>, and null if there is no such <a>slot</a> element otherwise.</li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>
              Otherwise:
              <ol>
                <li>Let <var>SLOT</var> be null</li>
              </ol>
            </li>
          </ol>
        </div>
      </section>

      <section>
        <h2>Assigned Nodes Algorithm</h2>

        <p>
          The <dfn>get assigned nodes algorithm</dfn> <strong>must</strong> be used to determine the <dfn>assigned nodes</dfn> of a <a>slot</a> and <strong>must</strong> be <a data-lt="processing equivalence">equivalent</a> to processing the following steps:
        </p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>SLOT</var>, a <a>slot</a></dd>
            <dt>Output</dt>
            <dd><var>ASSIGNED-NODES</var>, an ordered list of nodes</dd>
          </dl>

          <ol>
            <li>
              If <var>SLOT</var> participates in a shadow tree:
              <ol>
                <li>Let <var>HOST</var> be a <a>shadow host</a> which <a>hosts</a> the <a>shadow tree</a></li>
                <li>
                  For each child node <var>NODE</var> of <var>HOST</var>:
                  <ol>
                    <li>
                      If <var>NODE</var> is <a data-lt="assigned slot">assigned</a> to <var>SLOT</var>:
                      <ol>
                        <li>Append <var>NODE</var> to <var>ASSIGNED-NODES</var></li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </div>
      </section>

      <section>
        <h2>Distributed Nodes Algorithm</h2>

        <p>
          The <dfn>get distributed nodes algorithm</dfn> <strong>must</strong> be used to determine the <dfn>distributed nodes</dfn> of a <a>slot</a> and <strong>must</strong> be <a data-lt="processing equivalence">equivalent</a> to processing the following steps:
        </p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>SLOT</var>, a <a>slot</a></dd>
            <dt>Output</dt>
            <dd><var>DISTRIBUTED-NODES</var>, an ordered list of nodes.</dd>
          </dl>

          <ol>
            <li>
              If the <a>assigned nodes</a> of <var>SLOT</var> is empty:
              <ol>
                <li>Let <var>ASSIGNED-OR-FALLBACK-CONTENT</var> be the child nodes of <var>SLOT</var></li>
              </ol>
            </li>
            <li>
              Otherwise:
              <ol>
                <li>Let <var>ASSIGNED-OR-FALLBACK-CONTENT</var> be the <a>assigned nodes</a> of <var>SLOT</var></li>
              </ol>
            </li>
            <li>
              For each node <var>NODE</var> of <var>ASSIGNED-OR-FALLBACK-CONTENT</var>:
              <ol>
                <li>
                  If <var>NODE</var> is a <a>slot</a>:
                  <ol>
                    <li>Let <var>SUB-LIST</var> be the result of (recursively) running the <a>get distributed nodes algorithm</a> with <var>NODE</var> as input</li>
                    <li>Append all nodes in <var>SUB-LIST</var> to <var>DISTRIBUTED-NODES</var></li>
                  </ol>
                </li>
                <li>
                  Otherwise:
                  <ol>
                    <li>Append <var>NODE</var> to <var>DISTRIBUTED-NODES</var> if <var>NODE</var> is <a>slot assignable</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </div>
      </section>

    </section>

    <section>
      <h2>Flattening</h2>

      <section>
        <h3>Flattening Algorithm</h3>


        <p>The <dfn>flat tree children calculation algorithm</dfn> <strong>must</strong> be used to determine the child nodes of a node in the <a>flat tree</a> and <strong>must</strong> be <a data-lt="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>NODE</var>, a <a>node</a> which participates in a flat tree</dd>
            <dt>Output</dt>
            <dd><var>CHILDREN</var>, the child nodes of <var>NODE</var> in the <a>flat tree</a>.</dd>
          </dl>

          <ol>
            <li>Let <var>CHILDREN</var> be an empty ordered list of nodes</li>
            <li>
              If <var>NODE</var> is a <a>shadow host</a>:
              <ol>
                <li>Let <var>CHILD-POOL</var> be the child nodes of the <a>shadow root</a> which <var>NODE</var> <a>hosts</a></li>
              </ol>
            </li>
            <li>
              Otherwise:
              <ol>
                <li>Let <var>CHILD-POOL</var> be the child nodes of <var>NODE</var></li>
              </ol>
            </li>
            <li>
              For each <a>node</a>, <var>CHILD</var>, in <var>CHILD-POOL</var>:
              <ol>
                <li>
                  If <var>CHILD</var> is a <a>slot</a>:
                  <ol>
                    <li>If <var>CHILD</var> is not assigned to any <a>slot</a>:
                      <ol>
                        <li>Append all nodes of the <a>distributed nodes</a> of <var>CHILD</var> to <var>CHILDREN</var></li>
                      </ol>
                    </li>
                  </ol>
                </li>
                <li>Otherwise:
                  <ol>
                    <li>Append <var>CHILD</var> to <var>CHILDREN</var> if <var>CHILD</var> is <a>slot assignable</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </div>

        <p>For a given <a>composed tree of node trees</a> <var>COMPOSED-TREE</var>, the <a>flat tree</a> constructed from <var>COMPOSED-TREE</var> <strong>must</strong> be <a data-lt="processing equivalence">equivalent</a> to the following tree:</p>
        <ul>
          <li>The <a>root</a> <a>node</a> of the <a>flat tree</a> is the <a>root</a> <a>node</a> of the <a>root tree</a> of <var>COMPOSED-TREE</var>.</li>
          <li>For a given <a>node</a> which <a>participates</a> in the <a>flat tree</a>, the child <a data-lt="node">nodes</a> of the <a>node</a> is the result of the <a>flat tree children calculation algorithm</a> with the <a>node</a> as input.
          </li>
        </ul>
      </section>

      <section class="informative">
        <h3>Flattening Example</h3>

        <p>
          Suppose that we have the following composed tree of node trees:
        </p>

        <figure>
          <object data="../../assets/images/example-composed-tree.svg" width="581" height="616"></object>
          <figcaption>An example composed tree of node trees. A node whose color is red represents a <a>slot</a>. Unlike the previous figures, a box surrounding a node tree is omitted here. </figcaption>
        </figure>

        <p>
          This <a>composed tree of node trees</a> is composed of the following 3 <a data-lt="node tree">node trees</a>, one <a>document tree</a> and two <a data-lt="shadow tree">shadow trees</a>:
        </p>

        <table>
          <thead>
            <tr>
              <th>node tree</th>
              <th>Root node is: </th>
              <th>Hosted by:</th>
              <th>Composed of: (in tree order)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>document tree 1</td>
              <td>A</td>
              <td>-</td>
              <td>A, B, C, D, E, F, G, H, I</td>
            </tr>
            <tr>
              <td>shadow tree 1</td>
              <td>J</td>
              <td>C</td>
              <td>J, K, L, M, N, O, P, Q</td>
            </tr>
            <tr>
              <td>shadow tree 2</td>
              <td>R</td>
              <td>N</td>
              <td>R, S, T</td>
            </tr>
          </tbody>
        </table>

        <p>
          Suppose that an <a>assigned slot</a> of each node, if it exists, is:
        </p>

        <ul>
          <li>D: => L (You can read this as <strong>"D is assigned to L</strong>")</li>
          <li>F: => L</li>
          <li>H: => O</li>
          <li>O: => T</li>
          <li>P: => T</li>
        </ul>

        <figure>
          <object data="../../assets/images/example-slotting.svg" width="581" height="616"></object>
          <figcaption>A result of slotting.</figcaption>
        </figure>

        <p>
          Then, the <a>assigned nodes</a> and the <a>distributed nodes</a> of each slot will be:
        </p>

        <table>
          <thead>
            <tr>
              <th>node tree</th>
              <th>Root node is: </th>
              <th>Hosted by:</th>
              <th>Composed of: (in tree order)</th>
              <th><a>Assigned slot</a> of each node</th>
              <th><a>Assigned nodes</a> of each slot</th>
              <th><a>Distributed nodes</a> of each slot</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>document tree 1</td>
              <td>A</td>
              <td>-</td>
              <td>A, B, C, D, E, F, G, H, I</td>
              <td>
                <ul>
                  <li>D: => L</li>
                  <li>F: => L</li>
                  <li>H: => O</li>
                </ul>
              </td>
              <td>-</td>
              <td>-</td>
            </tr>
            <tr>
              <td>shadow tree 1</td>
              <td>J</td>
              <td>C</td>
              <td>J, K, L, M, N, O, P, Q</td>
              <td>
                <ul>
                  <li>O: => T</li>
                  <li>P: => T</li>
                </ul>
              </td>
              <td>
                <ul>
                  <li>L: [D, F]</li>
                  <li>M: []</li>
                  <li>O: [H]</li>
                </ul>
              </td>
              <td>
                <ul>
                  <li>L: [D, F]</li>
                  <li>M: []</li>
                  <li>O: [H]</li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>shadow tree 2</td>
              <td>R</td>
              <td>N</td>
              <td>R, S, T</td>
              <td>-</td>
              <td>
                <ul>
                  <li>T: [O, P]</li>
                </ul>
              </td>
              <td>
                <ul>
                  <li>T: [H, P]
                  </li>
                </ul>
              </td>
            </tr>
          </tbody>
        </table>

        <ul class="note">
          <li>More than one nodes can be assigned to the same slot. e.g. D: => L, F: => L</li>
          <li>A slot can be assigned to an other slot, e.g. O: => T</li>
          <li>
            The <a>distributed nodes</a> of T are [H, P]. That aren't [O, P].
            A slot is never a member of distributed nodes of an other slot.
            If a slot <var>A</var> is assigned to an other slot <var>B</var>, the distributed nodes for <var>A</var> are appended to the distributed nodes for <var>B</var>,
            instead of <var>A</var> itself, as per the <a>get distributed nodes algorithm</a>.
          </li>
        </ul>

        <p>
          The document flat tree will be:
        </p>

        <figure>
          <object data="../../assets/images/example-flat-tree.svg" width="256" height="526"></object>
          <figcaption>Document flat tree.</figcaption>
        </figure>

        <ul class="note">
          <li>A slot never participates in a <a>document flat tree</a>. Neither a <a>shadow root</a> does.</li>
          <li>Node G doesn't participate in the <a>document flat tree</a>. G is a child of a shadow host, but it's not assigned to any slot.</li>
          <li>In an extreme case, even if a document tree has more than 1,000 nodes, you can make the page *blank* by attaching a shadow root to the <code>body</code> element because a document flat tree is used in rendering.</li>
        </ul>
    </section>

    </section>

    <section>
      <h2>Events</h2>

      <p>
        In each algorithm in this section, the <a>Window</a> <strong>must</strong> be considered as if it were the parent node of the <a>Document</a> so that the <a>Window</a> also receives an <a>event</a>.
      </p>

      <p class="note">
        This section assumes that an event target is a <code>Node</code> object.
        This section is not applied for an event whose event target is not a <code>Node</code> object, such as IndexedDB, XHR and so on.
        See <a href="https://github.com/w3c/webcomponents/issues/61">Issue #61</a> for details.
        Eventually, DOM Standard should clarify this.
      </p>

      <section>
        <h3>Event Paths</h3>

        <section>
          <h3>scoped flag</h3>

          <p>
            A trusted event's <a><code>scoped flag</code></a> <strong>must</strong> be initialized to true
            if the event is one of the following events: <code>abort</code>, <code>error</code>, <code>select</code>, <code>change</code>, <code>load</code>, <code>loadedmetadata</code>, <code>reset</code>,
            <code>resize</code>, <code>scroll</code> and <code>selectstart</code>.
          </p>
        </section>

        <section>
          <h3>relatedTargetScoped flag</h3>

          <p>
            A trusted event's <a><code>relatedTargetScoped flag</code></a> <strong>must</strong> be initialized to true
            if the event has a <code>relatedTarget</code> property [[!DOM-Level-3-Events]] whose value is non-null.
          </p>
        </section>

        <section>
          <h3>get the parent</h3>

          <p>
            The <a>get the parent</a> algorithm associated with <code>Node</code> <strong>must</strong> be <a data-lt="processing equivalence">equivalent</a> to processing the following steps:
          </p>

          <div class="algorithm">
            <dl>
              <dt>Input</dt>
              <dd><var>NODE</var>, a context object</dd>
              <dd><var>TARGET</var>, an eventPath's last item</dd>
              <dd><var>EVENT</var>, an event</dd>
              <dt>Output</dt>
              <dd><var>PARENT</var>, the parent</dd>
            </dl>
            <ol>
              <li>
                If all of the following conditions are satisfied, let <var>PARENT</var> be null:
                <ol>
                  <li><var>NODE</var> is a <a>shadow root</a></li>
                  <li><var>NODE</var> is the <a>root</a> node of <var>TARGET</var></li>
                  <li><var>EVENT</var>'s <a>scoped flag</a> is true</li>
                </ol>
              </li>
              <li>
                Otherwise, if all of the following conditions are satisfied, let <var>PARENT</var> be null:
                <ol>
                  <li>
                    <var>EVENT</var>'s <a>relatedTargetScoped flag</a> is true
                  </li>
                  <li>
                    <var>EVENT</var> has a <code>relatedTarget</code> property whose value is non-null
                  </li>
                  <li>
                    The <a>relative target</a> and the <a>relative related target</a> are the same, where:
                    <ul>
                      <li>
                        The <a>relative target</a> is the result of <a>retargeting algorithm</a> with <var>NODE</var> and <var>TARGET</var> as input
                      </li>
                      <li>
                        The <a>relative related target</a> is the result of <a>retargeting algorithm</a> with <var>NODE</var> and <var>EVENT</var>'s <code>relatedTarget</code> as input
                      </li>
                    </ul>
                  </li>
                </ol>
                <li>
                  Otherwise, if <var>NODE</var> is assigned to a <a>slot</a> <var>SLOT</var>:
                  <ol>
                    <li>Let <var>PARENT</var> be <var>SLOT</var></li>
                  </ol>
                </li>
                <li>
                  Otherwise:
                  <ol>
                    <li>Let <var>PARENT</var> be the <a>shadow-including parent</a> of <var>NODE</var></li>
                  </ol>
                </li>
              </li>
            </ol>
          </div>

          <p>
            The definitions of <a>retargeting algorithm</a> is specified later.
          </p>

          <div class="note">
            <p>
              The motivation of the <a>relatedTargetScoped flag</a> is to avoid the appearance of spurious events, such as <code>mouseover</code> or <code>mouseout</code> events, firing at the node in ancestor trees
              in cases where both <code>relatedTarget</code> and <code>target</code> are part of the same <a>shadow tree</a>,
            </p>
          </div>

        </section>

        <section class="informative">
          <h3>Event Paths Example</h3>

          <p>
            Let's re-use the same composed tree of node trees used in the flattening example section. Suppose that an event is dispatched on node <code>I</code>. The event path will be:
          </p>
          <p>
            <code>[I, H, O, T, S, R, N, J, C, A]</code>  (For the purpose of the explanation, <a>Window</a> is not shown here. The actual event path contains <a>Window</a>.)
          </p>

          <p>
            It's worth pointing out that if we exclude all nodes which don't participate in the flat tree from the event path,
            the result would be equivalent to the inclusive ancestors of the node <code>I</code> in the flat tree.
          </p>

          <figure>
            <object data="../../assets/images/event-path-flat-tree.svg" width="580" height="560"></object>
            <figcaption>
              The relationship between the <a>flat tree</a> and an event path.
              If we exclude O, T, R and J, that don't participate in the flat tree, from the event path,
              the result would be equivalent to the inclusive ancestors of the node, <code>I</code>, in the <a>flat tree</a>.
            </figcaption>
          </figure>

          <p>
            Note that the <a>get the parent</a> algorithm associated with <code>Node</code> is designed to achieve the following goals:
          </p>

          <ol>
            <li>
              If there is a node, <var>CHILD</var>, in the event path and <var>CHILD</var> has a parent node, <var>PARENT</var>, in the node tree, the event path always includes <var>PARENT</var>.
              <var>PARENT</var> always appears somewhere after <var>CHILD</var> in the event path.
            </li>
            <li>
              Nodes in the event path form a <em>linear ancestor chain</em> in each <a>node tree</a>. There are no <em>branch points</em> in each <a>node tree</a>.
            </li>
          </ol>

          <figure>
            <object data="../../assets/images/event-path-component-trees.svg" width="766" height="386">></object>
            <figcaption>
              The relationship between an event path and node trees. In the figure, a number shown in a right-side of each node represents a zero-based position of each node in the event path.
              A parent node always has a larger number than that of its child node in each node tree.
            </figcaption>
          </figure>

          <p>A <em>local</em> event path for each node tree would be seen as:
          </p>

          <table>
            <thead>
              <tr>
                <th>node tree</th>
                <th><em>Local</em> Event Path</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>document tree 1</td>
                <td>[I, H, C, A]</td>
              </tr>
              <tr>
                <td>shadow tree 1</td>
                <td>[O, N, J]</td>
              </tr>
              <tr>
                <td>shadow tree 2</td>
                <td>[T, S, R]</td>
              </tr>
            </tbody>
          </table>

          <p>
            That means, if your concern is only one <a>node tree</a>, you can forget all other node trees.
            The event path would be seen as if the event happened only on the node tree you are focusing on.
            This is an important aspect in a sense that hosting a shadow tree doesn't have any effect to the <em>local</em> event path
            as long as the event is not stopped somewhere in the <a data-lt="descendant tree">descendant trees</a>.
          </p>
          <p>
            If you are a web author and your concern is only a document tree, this might be a good news because an event listener that is registered somewhere on the document tree
            would <em>continue to work</em> even when you attach a shadow root to an element in the document tree to <em>enhance</em> the element.
            At the same time, an author of a shadow tree also can receive an event which will happen on a node in the document tree, if the node, or its ancestor, is assigned to a slot in the shadow tree.
          </p>

        </section>
      </section>

      <section>
        <h3>Event Retargeting</h3>

        <section>
          <h3>Event <code>target</code> Retargeting</h3>

          <p>The value of the <code>Event</code> object's <a><code>target</code></a> attribute <strong>must</strong> be the result of the <a>retargeting algorithm</a> with the event's <code>currentTarget</code> and original <code>target</code> value, before adjusted, as input. The result is called a <dfn>relative target</dfn>.
          </p>

          <p>The <dfn>retargeting algorithm</dfn> <strong>must</strong> be <a data-lt="processing equivalence">equivalent</a> to processing the following steps:</p>

          <div class="algorithm">
            <dl>
              <dt>Input</dt>
              <dd><var>BASE</var>, a base node for which a target node should be adjusted</dd>
              <dd><var>TARGET</var>, a target node which should be adjusted</dd>
              <dt>Output</dt>
              <dd><var>RELATIVE-TARGET</var>, a <a>relative target</a>, the result of adjusting <var>TARGET</var> for <var>BASE</var></dd>
            </dl>
            <ol>
              <li>Let <var>BASE-TREE</var> be the <a>node tree</a> which <var>BASE</var> <a>participates</a> in</li>
              <li>Let <var>TARGET-TREE</var> be the <a>node tree</a> which <var>TARGET</var> <a>participates</a> in</li>
              <li>If <var>BASE-TREE</var> and <var>TARGET-TREE</var> participate in the same <a>composed tree of node trees</a>:
                <ol>
                  <li>Let <var>COMMON-ANCESTOR-TREE</var> be the lowest common <a>inclusive ancestor tree</a> of <var>BASE-TREE</var> and <var>TARGET-TREE</var></li>
                </ol>
              </li>
              <li>Otherwise:
                <ol>
                  <li>Let <var>COMMON-ANCESTOR-TREE</var> be the <a>root tree</a> of <var>TARGET-TREE</var></li>
                </ol>
              </li>
              <li>
                For each <a>node</a>, <var>ANCESTOR</var>, in <a>shadow-including inclusive ancestor</a> nodes of <var>TARGET</var>, from descendants to ancestors:
                <ol>
                  <li>
                    If <var>ANCESTOR</var> participates in <var>COMMON-ANCESTOR-TREE</var>:
                    <ol>
                      <li>Let <var>RELATIVE-TARGET</var> be <var>ANCESTOR</var></li>
                      <li>Stop this algorithm</li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </div>

          <p>
            Event <dfn>retargeting</dfn> is a process of computing relative targets for each ancestor of the <a>node</a> at which the event is dispatched.
            The event target <a>retargeting</a> process <strong>must</strong> occur prior to dispatch of an event.
            In other words, any DOM mutation occurred in an event listener does not have any affect on the result of retargeting process.
          </p>

          <p class="note">
            The motivation of <a>retargeting</a> is to maintain an encapsulation in the cases where event path is across multiple node trees.
            The event's <code>target</code> might not be an <a>unclosed node</a> at some of nodes in the event path without <a>retargeting</a>.
            A <a>relative target</a> is a <a>unclosed node</a> that most accurately represents the target of a dispatched event at each node in the event path.
          </p>
        </section>

        <section>
          <h3>Event <code>relatedTarget</code> Retargeting</h3>

          <p>Some events have a <a><code>relatedTarget</code></a> property, which holds a <a>node</a> that's not the event's target, but is related to the event.</p>

          <p>
            The value of the <code>Event</code> object's <a><code>relatedTarget</code></a> attribute <strong>must</strong> be the result of the <a>retargeting algorithm</a> with the event's <code>currentTarget</code> and <code>relatedTarget</code> as input.
            The result is called a <dfn>relative related target</dfn>.
          </p>

          <p>
            The event relatedTarget retargeting process <strong>must</strong> occur prior to dispatch of an event.
          </p>
        </section>

        <section>
          <h3>Touch Events Retargeting </h3>

          <p>The <a><code>Touch</code></a> <a data-lt="Touch target"><code>target</code></a> [[!TOUCH-EVENTS]] attribute <strong>must</strong> be adjusted in the same way as an event with a <a><code>relatedTarget</code></a>. Each <a><code>Touch</code></a> <a data-lt="Touch target"><code>target</code></a> in the <a><code>TouchList</code></a> returned from <a><code>TouchEvent</code></a> <a data-lt="touches"><code>touches()</code></a>, <a data-lt="changedTouches"><code>changedTouches()</code></a> and <a data-lt="targetTouches"><code>targetTouches()</code></a> must be the result of the <a>retargeting algorithm</a> with a current target and <a><code>Touch</code></a> <a data-lt="Touch target"><code>target</code></a> as input.</p>
        </section>

        <section class="informative">
          <h3>Event Retargeting Example</h3>

          <p>Suppose we have a user interface for a media controller, represented by this tree, composed of both <a>document tree</a> and the <a data-lt="shadow tree">shadow trees</a>. In this example, we will assume that selectors are allowed to cross the shadow boundaries and we will use these selectors to identify the <a data-lt="element">elements</a>. Also, we will invent a fictional <code>shadow-root</code> <a>element</a> to demarcate the shadow boundaries and represent <a data-lt="shadow root">shadow roots</a>:</p>
          <pre class="example">
  &lt;div id="player"&gt;
      <span class=shadow-boundary>&lt;shadow-root id="player-shadow-root"&gt;</span>
          &lt;div id="controls"&gt;
              &lt;button id="play-button"&gt;PLAY&lt;/button&gt;
              &lt;input type="range" id="timeline"&gt;
                  <span class=shadow-boundary>&lt;shadow-root id="timeline-shadow-root"&gt;</span>
                      &lt;div id="slider-thumb" id="timeline-slider-thumb"&gt;&lt;/div&gt;
                  <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
              &lt;/input&gt;
              &lt;div id="volume-slider-container"&gt;
                  &lt;input type="range" id="volume-slider"&gt;
                      <span class=shadow-boundary>&lt;shadow-root id="volume-shadow-root"&gt;</span>
                          &lt;div id="slider-thumb" id="volume-slider-thumb"&gt;&lt;/div&gt;
                      <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
                  &lt;/input&gt;
              &lt;/div&gt;
          &lt;/div&gt;
      <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
  &lt;/div&gt;
          </pre>

          <p>Let's have a user position their pointing device over the volume slider's thumb (<code>#volume-slider-thumb</code>), thus triggering a <code>mouseover</code> event on that node. For this event, let's pretend it has no associated <code>relatedTarget</code>.</p>

          <p>Per the <a>retargeting algorithm</a>, we should have the following set of ancestors and relative targets:</p>
          <table>
            <thead>
              <tr>
                <th>Ancestor</th>
                <th>Relative Target</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>#player</code></td>
                <td><code><strong>#player</strong></code></td>
              </tr>
              <tr>
                <td><code>#player-shadow-root</code></td>
                <td><code>#volume-slider</code></td>
              </tr>
              <tr>
                <td><code>#controls</code></td>
                <td><code>#volume-slider</code></td>
              </tr>
              <tr>
                <td><code>#volume-slider-container</code></td>
                <td><code>#volume-slider</code></td>
              </tr>
              <tr>
                <td><code>#volume-slider</code></td>
                <td><code><strong>#volume-slider</strong></code></td>
              </tr>
              <tr>
                <td><code>#volume-shadow-root</code></td>
                <td><code>#volume-slider-thumb</code></td>
              </tr>
              <tr>
                <td><code>#volume-slider-thumb</code></td>
                <td><code><strong>#volume-slider-thumb</strong></code></td>
              </tr>
            </tbody>
          </table>

          <p>After we dispatch the <code>mouseover</code> event using these newly computed relative targets, the user decides to move their pointing device over the thumb of the timeline
            (<code>#timeline-slider-thumb</code>). This triggers both a <code>mouseout</code> event for the volume slider thumb and the <code>mouseover</code> event for the timeline thumb.</p>

          <p>Let's see how the <code>relatedTarget</code> value of the volume thumb's <code>mouseout</code> event is affected. For this event, the <code>relatedTarget</code> is the timeline thumb (<code>#timeline-slider-thumb</code>). Per the <a href="#retargeting-relatedtarget">relatedTarget retargeting</a>, we should have the following set of ancestors and adjusted related targets:</p>

          <table>
            <thead>
              <tr>
                <th>Ancestor</th>
                <th>Relative Target</th>
                <th>Relative Related Target</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>#player</code></td>
                <td><code><strong>#player</strong></code></td>
                <td><code><strong>#player</strong></code></td>
              </tr>
              <tr>
                <td><code>#player-shadow-root</code></td>
                <td><code>#volume-slider</code></td>
                <td><code>#timeline</code></td>
              </tr>
              <tr>
                <td><code>#controls</code></td>
                <td><code>#volume-slider</code></td>
                <td><code>#timeline</code></td>
              </tr>
              <tr>
                <td><code>#volume-slider-container</code></td>
                <td><code>#volume-slider</code></td>
                <td><code>#timeline</code></td>
              </tr>
              <tr>
                <td><code>#volume-slider</code></td>
                <td><code><strong>#volume-slider</strong></code></td>
                <td><code>#timeline</code></td>
              </tr>
              <tr>
                <td><code>#volume-shadow-root</code></td>
                <td><code>#volume-slider-thumb</code></td>
                <td><code>#timeline</code></td>
              </tr>
              <tr>
                <td><code>#volume-slider-thumb</code></td>
                <td><code><strong>#volume-slider-thumb</strong></code></td>
                <td><code><strong>#timeline</strong></code></td>
              </tr>
            </tbody>
          </table>

          <p>The node, <code>#player</code>, has both <code>target</code> and <code>relatedTarget</code> being the same value (<code>#player</code>), which means that we do not dispatch the event on this <a>node</a> and its ancestors.</p>
        </section>

      </section>

      <section>
        <h3>Event Dispatch</h3>

        <p>At the time of event dispatch:</p>
        <ul>
          <li>The <a><code>MouseEvent</code></a> <a><code>offsetX</code></a> and <a><code>offsetY</code></a> attributes <strong>must</strong> return the coordinates relative to the origin of the <a>padding edge</a> of the <a>relative target</a></li>
          <li>When <em>capturing</em>, which entails processing step 6 of the <a data-lt="event dispatch">event dispatch algorithm</a>, the event listeners <strong>must not</strong> be <a data-lt="event listener invoke">invoked</a> on a <a>node</a> <strong>if</strong> it is the same as its <a>relative target</a></li>
          <li>When <em>bubbling</em>, which entails processing step 9 of the <a data-lt="event dispatch">event dispatch algorithm</a>, the <a><code>Event</code></a> <a>eventPhase</a> attribute <strong>must</strong> return <a>AT_TARGET</a> <strong>if</strong> the <a>relative target</a> is same as the <a>node</a> on which event listeners are <a data-lt="event listener invoke">invoked</a></li>
          <li>If the event's <a><code>bubbles</code></a> attribute value is <strong>false</strong>, run these substeps:
            <ol>
              <li>Reverse the order of <em>event path</em></li>
              <li>Initialize event's <a><code>eventPhase</code></a> attribute to <a><code>AT_TARGET</code></a></li>
              <li>For each object in <em>event path</em> where the <a>relative target</a> is same as the object, <a data-lt="event listener invoke">invoke</a> its <a data-lt="event listener">event listeners</a>, with event <em>event</em>, as long as <em>event</em>'s <a>stop propagation flag</a> is unset</li>
            </ol></li>
        </ul>

        <p>Upon completion of the event dispatch, the <a><code>Event</code></a> object's <a><code>target</code></a> and <a><code>relatedTarget</code></a> <strong>must</strong> be to the highest ancestor's <a>relative target</a> and <a>relative related target</a>, respectively. Since it is possible for a script to hold on to the <code>Event</code> object past the scope of event dispatch, this step is necessary to avoid revealing the <a data-lt="node">nodes</a> in <a data-lt="shadow tree">shadow trees</a>.</p>

        <p>
          The <a data-lt="mutation event">mutation event types</a> <strong>must</strong> never be dispatched in a <a>shadow tree</a>.
        </p>

      </section>

    </section>

    <section>
      <h2>User Interaction</h2>

      <section class="informative">
        <h3>Ranges and Selections</h3>

        <p>
          <a>Selection</a> [[!EDITING]] is not defined. Implementation should do their best to do what's best for them. Here's one possible, admittedly naive way:
        </p>

        <p>Since <a data-lt="node">nodes</a> which are in the different <a data-lt="node tree">node trees</a> never have the same <a>root</a>, there may never exist a valid <a data-lt="range">DOM range</a> that spans multiple <a data-lt="node tree">node trees</a>.</p>

        <p>Accordingly, <a data-lt="selection">selections</a> may only exist within one <a>node tree</a>, because they are defined by a single <a>range</a>. The <a>selection</a>, returned by the <a><code>window.getSelection()</code></a> method never returns a <a>selection</a> within a <a>shadow tree</a>.</p>

        <p>The <code>getSelection()</code> method of the <a>shadow root</a> object returns the current <a>selection</a> in this <a>shadow tree</a>.</p>
      </section>

      <section>
        <h3>Focus</h3>
        <p>A <a>shadow host</a> can delegate focus to its <a>shadow root</a> by assigning a boolean <a href="#widl-ShadowRootInit-delegatesFocus">delegatesFocus</a> flag to be true in <a href="#idl-def-ShadowRootInit">ShadowRootInit</a> dictionary. If omitted, a <a>shadow host</a> does not delegate focus to its shadow root, and the shadow host itself can be focusable.</p>
        <p>When a shadow host delegates focus, user agent <strong>must</strong> behave as follows.
          <ol>
            <li>When the <a>shadow host</a> is being focused by TAB focus navigation: if the direction is forward, the first focusable element in its <a>shadow tree</a> gets focuse. If the direction is backward, the last focusable element in its <a>shadow tree</a> gets focuse. If there is no focusable element in its <a>shadow tree</a>, the <a>shadow host</a> is skipped for the navigation. See the next secition for the formal definition.</li>
            <li>When the <a>shadow host</a> is being focused by <code>focus()</code> method or <code>autofocus</code> attribute: The first focusable element in its <a>shadow tree</a> gets focus.</li>
            <li>When non-focusable area in its <a>shadow tree</a> is clicked: The first focusable element in its <a>shadow tree</a> gets focus.</li>
            <li>When a focusable element in its <a>shadow tree</a> is clicked: The element itself gets focus.</li>
            <li>When any of its <a>shadow tree</a> has focus, <code>:focus</code> pseudo-class on the shadow host matches.</li>
          </ol>
        </p>
      </section>

      <section>
        <h3>Focus Navigation</h3>

        <p>If a <a>node</a> doesnt <a data-lt="participates">participate</a> in the <a>document flat tree</a>, the <a>node</a> <strong>must</strong> be skipped from the <a>sequential focus navigation</a>.</p>

        <p>The <a>sequential focus navigation order</a> for a given <a>shadow tree</a> <var>A</var> <strong>must</strong> be inserted into the <a>sequential focus navigation order</a> for the <a>parent tree</a> <var>B</var> as follows:</p>
        <ol>
          <li>Let <var>HOST</var> be the <a>shadow host</a> which <a>hosts</a> A</li>
          <li>
            The <a>sequential focus navigation order</a> for A <strong>must</strong> be inserted into the <a>sequential focus navigation order</a> for <var>B</var>:
            <ol>
              <li>immediately after <var>HOST</var>, if <var>HOST</var> is <a>focusable</a>; or</li>
              <li>in place of the <var>HOST</var> as if <var>HOST</var> were assigned the <a>tabindex</a> value 0 for determining its position.</li>
            </ol>
          </li>
        </ol>

        <p>For <a>directional focus navigation</a> [[!CSS3-UI]], it is up to the user agent to integrate the <a data-lt="shadow tree">shadow trees</a> into the document's <a>directional focus navigation</a>.
      </section>

      <section>
        <h3>Active Element</h3>

        <p>To maintain encapsulation, the value of the <a data-lt="Document object">Document</a> object's focus API property <a>activeElement</a> <strong>must</strong> be adjusted. To prevent loss of information when adjusting this value, each <a>shadow root</a> <strong>must</strong> also have an <code>activeElement</code> property to store the value of the focused <a>element</a> in the <a>shadow tree</a>.</p>

        <p>
          The <dfn>active element adjustment algorithm</dfn> <strong>must</strong> be used to determine the value of <a>activeElement</a> property, and it <strong>must</strong> be <a data-lt="processing equivalence">equivalent</a> to processing the following steps:
        </p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>ROOT</var>, either a <a>document</a> or a <a>shadow root</a></dd>
            <dd><var>ELEMENT</var>, the focused <a>element</a></dd>
            <dt>Output</dt>
            <dd><var>ADJUSTED</var>, an adjusted <a>activeElement</a> property of <var>ROOT</var>.</dd>
          </dl>
          <ol>
            <li>Let <var>ADJUSTED</var> be the result of the <a>retargeting algorithm</a> with <var>ROOT</var> and <var>ELEMENT</var> as input</li>
          </ol>
        </div>
      </section>

      <section>
        <h3>Editing</h3>

        <p>The value of the <a><code>contenteditable</code></a> attribute <strong>must not</strong> propagate from <a>shadow host</a> to its <a data-lt="shadow tree">shadow trees</a>.</p>
      </section>

      <section>
        <h3>Assistive Technology</h3>

        <p>User agents with assistive technology traverse the <a>flat tree</a>, and thus enable full use of WAI-ARIA [[!WAI-ARIA]] semantics in the <a data-lt="shadow tree">shadow trees</a>.</p>

      </section>

      <section>
        <h3>Hit Testing</h3>

        <p>
          When a text node is a child node of a shadow root, a hit testing <strong>must</strong> target the shadow host if the text node is the result of the hit testing.
        </p>
        <p>
          User-agent mouse events <strong>must</strong> be targeted to the parent node in the <a>flat tree</a> of a text node if the <a>topmost event target</a> is the text node.
        </p>
        <p class="note">
          This section eventually needs to be part of some general hit testing specification.
        </p>
      </section>

    </section>

    <section>
      <h2>HTML Elements in Shadow Trees</h2>

      <section>
        <h3>Inertness of HTML Elements in a shadow tree</h3>

        <p>Comparatively, a <a>shadow tree</a> can be seen as somewhere between <em>just part of a <a>document</a></em> and itself being a <a data-lt="interface DocumentFragment">document fragment</a>. Since it is rendered, a <a>shadow tree</a> aims to retain the traits of a typical <a>tree</a> in a <a>document</a>. At the same time, it is an encapsulation abstraction, so it has to avoid affecting the <a>document tree</a>. Thus, the <a>HTML elements</a> <strong>must</strong> behave as specified [[!HTML]] in the <a data-lt="shadow tree">shadow trees</a>, with a few exceptions.</p>

        <p class="note">
          According to the [[!HTML]], some HTML Elements would have different behavior if they participate in a <a>shadow tree</a>, instead of a document tree,
          because their definitions require the elements to be <a>in a document</a> as a necessary condition for them to work.
          In other words, they shouldn't work if they participate in a <a>shadow tree</a>, even when they are <a>in a shadow-including document</a>.
          We must fill this gap because we expect that most of HTML Elements behave in the same way as <a>in a document</a>, as long as they are <a>in a shadow-including document</a>.
          See W3C <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=26365">Bug 26365</a> and <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27406">Bug 27406</a> for the details.
          The following is the tentative summary of the discussions in the W3C bugs. We, however, haven't covered all HTML Elements and their behaviors here yet.
          For HTML Elements which are not explicitly stated here, they should be considered as <a>active in a shadow tree</a>.
          We are trying to update [[!HTML]] itself, instead of having monkey patches here.
        </p>
        <p>
          HTML Elements are classified into the following categories:
        </p>
        <ul>
          <li>
            <p>
              <dfn>Active in a shadow tree</dfn>
            </p>
            <p>
              A subset of <a>HTML elements</a> which <strong>must</strong> behave as if they were in the <a>document tree</a>, even when they participate in a <a>shadow tree</a>,
              as long as they are <a>in a shadow-including document</a>.
            </p>
            <p>
              The following HTML elements <strong>must</strong> be classified to this category:
            </p>
            <ul>
              <li><code>dialog</code></li>
              <li><code>iframe</code></li>
              <li><code>style</code></li>
            </ul>
          </li>
          <li>
            <p>
              <dfn>Inert in a shadow tree</dfn>:
            </p>
            <p>
              A subset of <a>HTML elements</a> which <strong>must</strong> behave as <a>inert</a>, or not part of the <a>document tree</a>, if they participate in a <a>shadow tree</a>.
              This is consistent how the <a>HTML elements</a> would behave in a <a data-lt="interface DocumentFragment">document fragment</a>.
            </p>
            <p>
              The following HTML elements <strong>must</strong> be classified to this category:
            </p>
            <ul>
              <li><a data-lt="base element"><code>base</code></a></li>
              <li><a data-lt="link element"><code>link</code></a></li>
            </ul>
          </li>
          <li>
            <p>
              <dfn>Inert unless being rendered</dfn>:
            </p>
            <p>
              A subset of <a>HTML elements</a> which <strong>must</strong> behave as <a>inert</a>, or not part of the <a>document tree</a>,
              unless they are <a>being rendered</a>.
              In other words, if they don't particitpate in a <a>document flat tree</a>, they <strong>must</strong> behave as <a>inert</a>.
            </p>
            <p>
              The following HTML elements <strong>must</strong> be classified to this category:
            </p>
            <ul>
              <li><code>applet</code></li>
              <li><code>embed</code></li>
              <li><code>object</code></li>
            </ul>
            <p class="note">
              For example, suppose that an <code>object</code> element is a child node of a shadow host, but the <code>object</code> element is not assigned to a slot.
              In this case, according to the <a>flat tree children calculation algorithm</a>,
              this element never participate in a <a>document flat tree</a>.
              Therefore, this element is <a>inert</a> because this element is not <a>being rendered</a>. .
            </p>
          </li>
        </ul>
      </section>

      <section>
        <h3>Attributes</h3>

        <p>When [[!HTML]] defines the processing algorithms to traverse trees for the following attributes, they <strong>must</strong> use the <a>flat tree</a>.
        <ul>
          <li><code>dir</code></li>
          <li><code>draggable</code></li>
          <li><code>dropzone</code></li>
          <li><code>hidden</code></li>
          <li><code>lang</code> and <code>xml:lang</code></li>
          <li><code>spellcheck</code></li>
          <li><code>title</code></li>
        </ul>

        <div class="note">
          <p>
            This list does not include attributes that are defined elsewhere in this specification. Such attributes include:
          </p>
          <ul>
            <li><code>tabindex</code> is defined in <a href="#focus-navigation">Focus Navigation</a>.</li>
            <li><code>role</code> and <code>ARIA</code> are defined in <a href="#assistive-technology">Assistive Technology</a>.</li>
          </ul>
        </div>
      </section>

    </section>

    <section>
      <h2>Elements and DOM interfaces</h2>

      <section>
        <h3>Extensions to the <code><a href="https://dom.spec.whatwg.org/#documentorshadowroot">DocumentOrShadowRoot</a></code> Mixin</h3>

        <pre class='idl'>
          partial interface DocumentOrShadowRoot {
            Selection? getSelection ();
            Element? elementFromPoint(double x, double y);
            sequence&lt;Element&gt; elementsFromPoint(double x, double y);
            CaretPosition? caretPositionFromPoint(double x, double y);
            readonly attribute Element? activeElement;
            readonly attribute StyleSheetList styleSheets;
          };
        </pre>

        <ul class="note">
          <li>
            Except for <code>activeElement</code>, these methods and attributes are defined in the similar way as currently defined in Document,
            considering only the current node tree.
          </li>
          <li>
            Regarding <code>elementFromPoint</code> and <code>elementsFromPoints</code>, they should return the result of running the <a>retargeting algorithm</a> with <a>context object</a> and the original result as input.
          </li>
          <li>
            We should remove these methods and attributes from Document when this section is upstreamed to DOM Standard.
          </li>
        </ul>
      </section>

      <section>
        <h3>The <code>ShadowRoot</code> interface</h3>

        <p>The <code>ShadowRoot</code> interface represents the <a>shadow root</a>.</p>

        <dl class="idl" title="interface ShadowRoot : DocumentFragment">

          <dt>readonly attribute Element host</dt>
          <dd>
            <p>Represents the <a>shadow host</a> which <a>hosts</a> the <a>context object</a>.</p>
            <p>On getting, the attribute <strong>must</strong> return the <a>shadow host</a> which <a>hosts</a> the <a>context object</a>.</p>
          </dd>

          <dt>[TreatNullAs=EmptyString] attribute DOMString innerHTML</dt>
          <dd>
            This is similarly defined in Element's innerHTML with the following exceptions:
            <ul>
              <li>
                The <a>fragment serializing algorithm</a> <strong>must</strong> be invoked with the <a>shadow host</a> as input.
              </li>
              <li>
                The <a>fragment parsing algorithm</a> <strong>must</strong> use the <a>shadow host</a> as the context element.
              </li>
            </ul>

            <p class="note">
              Because <code>DocumentFragment</code> does not always have a <a>host</a>, <code>innerHTML</code> can not be defined in <code>DocumentFragment</code>.
            </p>
          </dd>
        </dl>

        <p>The <a><code>nodeType</code></a> attribute of a <a><code>ShadowRoot</code></a> instance <strong>must</strong> return <a><code>DOCUMENT_FRAGMENT_NODE</code></a>. Accordingly, the <a><code>nodeName</code></a> attribute of a <a><code>ShadowRoot</code></a> instance <strong>must</strong> return <code>"#document-fragment"</code>.</p>
      </section>

      <section>
        <h3>Extensions to <code>Element</code> Interface</h3>

        <dl class="idl" title="partial interface Element">
          <dt>ShadowRoot attachShadow(ShadowRootInit shadowRootInitDict)</dt>
          <dd>
            When invoked, these steps <strong>must</strong> be run:
            <ol>
              <li>
                If the <a>context object</a> is none of the following elements, throw a <code>NotSupportedError</code> exception.
                <ul>
                  <li>custom element</li>
                  <li><code>article</code></li>
                  <li><code>aside</code></li>
                  <li><code>blockquote</code></li>
                  <li><code>body</code></li>
                  <li><code>div</code></li>
                  <li><code>footer</code></li>
                  <li><code>h1</code></li>
                  <li><code>h2</code></li>
                  <li><code>h3</code></li>
                  <li><code>h4</code></li>
                  <li><code>h5</code></li>
                  <li><code>h6</code></li>
                  <li><code>header</code></li>
                  <li><code>nav</code></li>
                  <li><code>p</code></li>
                  <li><code>section</code></li>
                  <li><code>span</code></li>
                </ul>
                <p class="issue">
                  This list is possible to change. See <a href="https://github.com/w3c/webcomponents/issues/110">Issue #110</a>.
                </p>
              </li>
              <li>If the <a>context object</a> already hosts the shadow tree, throws <code>InvalidStateError</code> exception.</li>
              <li>
                Create a new instance of the <a><code>ShadowRoot</code></a> object.
                The <code>shadowRootInitDict</code> argument allows for setting the <a>mode</a>.
              </li>
              <li>Let the <a>context object</a> host the <a><code>ShadowRoot</code></a> object.</li>
              <li>Return <a><code>ShadowRoot</code></a> object.</li>
            </ol>
          </dd>

          <dt>readonly attribute HTMLSlotElement? assignedSlot</dt>
          <dd>
            <p>
              Represents the <a>assigned slot</a> of the <a>context object</a>.
            </p>
            <p>
              On getting, the attribute <strong>must</strong> return the <a>assigned slot</a> of the <a>context object</a>,
              if there is, and the assigned slot's <a>root</a>'s<a> mode</a> is "open".
              Otherwise <strong>must</strong> return <code>null</code>.
            </p>
          </dd>

          <dt>attribute DOMString slot</dt>
          <dd>
            <p>
              Reflects the <code>slot</code> attribute. The <code>slot</code> attribute represents the <a>slot name</a> of a slot to where this element is assigned.
            </p>
          </dd>

          <dt>readonly attribute ShadowRoot? shadowRoot</dt>
          <dd>
            <p>Represents the <a>shadow root</a> that <a>context object</a> <a>hosts</a>.</p>
            <p>On getting, the attribute <strong>must</strong> return the <a>shadow root</a> that <a>context object</a> <a>hosts</a> if there is and its <a>mode</a> is "open". Otherwise <strong>must</strong> return <code>null</code>.</p>
          </dd>
        </dl>
      </section>

      <section>
        <h3><code>ShadowRootInit</code> dictionary</h3>
        <dl class="idl" title="dictionary ShadowRootInit">
          <dt>required ShadowRootMode mode</dt>
          <dd>Specifies the associated <a>mode</a> of <a>ShadowRoot</a></dd>
          <dt>boolean delegatesFocus</dt>
          <dd>Specifies whether shadow host delegates focus to its <a>ShadowRoot</a>. If omitted, the default value is false.</dd>
        </dl>
      </section>

      <section>
        <h3><code>ShadowRootMode</code> enum</h3>
        <dl class="idl" title="enum ShadowRootMode">
          <dt>open</dt>
          <dd>Specifies "open" <a>mode</a></dd>
          <dt>closed</dt>
          <dd>Specifies "closed" <a>mode</a></dd>
        </dl>
      </section>

      <section>
        <h3>Extensions to <code>Text</code> Interface</h3>

        <dl class="idl" title="partial interface Text">
          <dt>readonly attribute HTMLSlotElement? assignedSlot</dt>
          <dd>
            <p>
              Represents the <a>assigned slot</a> of the <a>context object</a>.
            </p>
            <p>
              On getting, the attribute <strong>must</strong> return the <a>assigned slot</a> of the <a>context object</a>, if there is, and the assigned slot participates in an <a>open</a> shadow tree.
              Otherwise <strong>must</strong> return <code>null</code>.
            </p>
          </dd>
        </dl>
      </section>

      <section>
        <h3>The <code>slot</code> element</h3>

        <p>The <dfn>slot element</dfn> is used to define a location of a <a>slot</a>.</p>

        <dl>
          <dt>Context</dt>
          <dd>Where <a>flow content</a> is expected.</dd>

          <dt>Content model</dt>
          <dd><a>Transparent</a></dd>

          <dt>Children</dt>
          <dd>Anything as fallback content</dd>

          <dt>Content attributes</dt>
          <dd><a>Global attributes</a></dd>
          <dd>
            <dl>
              <dt><code>name</code>, the <a>slot name</a></dt>
              <dd>Represents the <a>slot name</a>.</dd>
            </dl>
          </dd>

          <dt>DOM Interface</dt>
          <dd>
            <dl class="idl" title="interface HTMLSlotElement : HTMLElement">
              <dt>attribute DOMString name</dt>
              <dd><strong>Must</strong> <a>reflect</a> the <a data-lt="slot name">name</a> attribute.</dd>
              <dt>sequence&lt;Node&gt; getAssignedNodes(optional AssignedNodesOptions options)</dt>
              <dd>
                When invoked, it <strong>must</strong> return a sequence consisting of either the <a>assigned nodes</a> or the <a>distributed nodes</a> of the <a>context object</a>.
                If the optional <var>options</var> is given and its <code>flatten</code> is true, the <a>distributed nodes</a> <strong>must</strong> be returned.
                Otherwise, the <a>assigned nodes</a> <strong>must</strong> be returned.
              </dd>
            </dl>
          </dd>
        </dl>
      </section>

      <section>
        <h3><code>AssignedNodesOptions</code> dictionary</h3>
        <dl class="idl" title="dictionary AssignedNodesOptions">
          <dt>boolean flatten = false</dt>
          <dd>
            <p>Specifies whether <code>getAssignedNodes()</code> returns <a>assigned nodes</a> or <a>distributed nodes</a></p>
          </dd>
        </dl>
      </section>

      <section>
        <h3>Extensions to <a><code>EventInit</code></a> Dictionary</h3>

        <dl class="idl" title="partial dictionary EventInit">
          <dt>boolean scoped = false</dt>
          <dd>
            <p>Specifies the <a>scoped flag</a> of <code>Event</code></p>
          </dd>
          <dt>boolean relatedTargetScoped = false</dt>
          <dd>
            <p>Specifies the <a>relatedTargetScoped flag</a> of <code>Event</code></p>
          </dd>
        </dl>
      </section>

      <section>
        <h3>Extensions to <code>Event</code> Interface</h3>

        <dl class="idl" title="partial interface Event">
          <dt>sequence&lt;EventTarget&gt; deepPath()</dt>
          <dd>
            <p>
              When invoked, it <strong>must</strong> return return a sequence consisting of event targets, that <strong>must</strong> be equivalent to processing the following steps:
            </p>
            <div class="algorithm">
              <dl>
                <dt>Input</dt>
                <dd><var>EVENT</var>, a <a>context object</a></dd>
                <dt>Output</dt>
                <dd><var>PATH</var>, an array of nodes</dd>
              </dl>

              <ol>
                <li>If <var>EVENT</var> hasn't been dispatched or <var>EVENT</var> is no longer dispatched, return a new empty array.</li>
                <li>
                  Otherwise:
                  <ol>
                    <li>Let <var>PATH</var> be the event path of <var>EVENT</var>.</li>
                    <li>Let PATH contain only a node which is an <a>unclosed node</a> of the <a>current target</a> of <var>EVENT</var>.</li>
                  </ol>
                </li>
              </ol>
            </div>
          </dd>
          <dt>readonly attribute boolean scoped</dt>
          <dd>
            <p>
              Returns the <dfn>scoped flag</dfn>.
            </p>
          </dd>
          <dt>readonly attribute boolean relatedTargetScoped</dt>
          <dd>
            <p>
              Returns the <dfn>relatedTargetScoped flag</dfn>.
            </p>
          </dd>
        </dl>
      </section>

    </section>

    <section>
      <h2>Shadow DOM Example</h2>

      <p>Bob was asked to turn a simple list of links into a News Widget, which has links organized into two categories: breaking news and just news. The current document markup for the stories looks like this:</p>
      <pre class="example highlight">
&lt;ul class="stories"&gt;
    &lt;li&gt;&lt;a href="//example.com/stories/1"&gt;A story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="//example.com/stories/2"&gt;Another story&lt;/a&gt;&lt;/li&gt;
    &lt;li class="breaking" slot="breaking"&gt;&lt;a href="//example.com/stories/3"&gt;Also a story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="//example.com/stories/4"&gt;Yet another story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="//example.com/stories/5"&gt;Awesome story&lt;/a&gt;&lt;/li&gt;
    &lt;li class="breaking" slot="breaking"&gt;&lt;a href="//example.com/stories/6"&gt;Horrible story&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      </pre>

      <p class="issue">
       It's weird that there are slot attributes in this markup because Bob has not decided to use Shadow DOM yet.
      </p>

      <p>To organize the stories, Bob decides to use <strong>shadow DOM</strong>. Doing so will allow Bob to keep the document markup uncluttered, and harnessing the power of insertion point makes sorting stories by class name a very simple task. After getting another cup of <a href="http://en.wikipedia.org/wiki/List_of_coffee_beverages#Green_Eye">Green Eye</a>, he quickly mocks up the following shadow tree, to be hosted by the <code>ul</code> element:</p>
      <pre class="example highlight">
&lt;div class="breaking"&gt;
    &lt;ul&gt;
        &lt;slot name="breaking"&gt;&lt;/slot&gt; &lt;!-- slot for breaking news --&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;div class="other"&gt;
    &lt;ul&gt;
        &lt;slot&gt;&lt;/slot&gt; &lt;!-- slot for the rest of the news --&gt;
    &lt;/ul&gt;
&lt;/div&gt;
      </pre>
      <p>Bob then styles the newborn widget according to comps from the designer by adding this to the shadow tree mockup:</p>
      <pre class="example highlight">
&lt;style&gt;
    div.breaking {
        color: Red;
        font-size: 20px;
        border: 1px dashed Purple;
    }
    div.other {
        padding: 2px 0 0 0;
        border: 1px solid Cyan;
    }
&lt;/style&gt;
      </pre>
      <p>While pondering if his company should start looking for a new designer, Bob converts the mockup to code:</p>
      <pre class="example highlight">
function createStoryGroup(className, slotName)
{
    var group = document.createElement('div');
    group.className = className;
    // Empty string in slot name attribute or absence thereof work the same, so no need for special handling.
    group.innerHTML = '&lt;ul&gt;&lt;slot name="' + slotName + '"&gt;&lt;/slot&gt;&lt;/ul&gt;';
    return group;
}

function createStyle()
{
    var style = document.createElement('style');
    style.textContent = 'div.breaking { color: Red;font-size: 20px; border: 1px dashed Purple; }' +
        'div.other { padding: 2px 0 0 0; border: 1px solid Cyan; }';
    return style;
}

function makeShadowTree(storyList)
{
    var root = storyList.attachShadow({mode: 'open'});
    root.appendChild(createStyle());
    root.appendChild(createStoryGroup('breaking', 'breaking'));
    root.appendChild(createStoryGroup('other', ''));
}

document.addEventListener('DOMContentLoaded', function() {
    [].forEach.call(document.querySelectorAll('ul.stories'), makeShadowTree);
});
      </pre>

      <p>Well done, Bob! With the cup of coffee still half-full, the work is complete. Recognizing his awesomeness, Bob returns to teaching n00bs the ways of <a href="https://en.wikipedia.org/wiki/Splatoon">Splatoon</a>.</p>
    </section>

    <section class="appendix">
      <h2>Acknowledgements</h2>

      <p><span class="vcard">David Hyatt</span> developed <a href="http://dev.w3.org/2006/xbl2/">XBL 1.0</a>, and <span class="vcard">Ian Hickson</span> co-wrote <a href="http://dev.w3.org/2006/xbl2/">XBL 2.0</a>. These documents provided tremendous insight into the problem of functional encapsulation and greatly influenced this specification.</p>

      <p><span class="vcard">Alex Russell</span> and his considerable forethought triggered a new wave of enthusiasm around the subject of shadow DOM and how it can be applied practically on the Web.</p>

      <p><span class="vcard">Dominic Cooney</span>, <span class="vcard">Hajime Morrita</span>, and <span class="vcard">Roland Steiner</span> worked tirelessly to scope the problem of functional encapsulation within the confines of the Web platform and provided a solid foundation for this document.</p>

      <p>The editor would also like to thank <span class="vcard">Alex Komoroske</span>, <span class="vcard">Anne van Kesteren</span>, <span class="vcard">Brandon Payton</span>, <span class="vcard">Brian Kardell</span>, <span class="vcard">Darin Fisher</span>, <span class="vcard">Eric Bidelman</span>, <span class="vcard">Deepak Sherveghar</span>, <span class="vcard">Edward O'Connor</span>, <span class="vcard">Elise Maurer</span>, <span class="vcard">Elliott Sprehn</span>, <span class="vcard">Erik Arvidsson</span>, <span class="vcard">Glenn Adams</span>, <span class="vcard">Jonas Sicking</span>, <span class="vcard">Koji Ishii</span>, <span class="vcard">Malte Ubl</span>, <span class="vcard">Mike Taylor</span>, <span class="vcard">Oliver Nightingale</span>, <span class="vcard">Olli Pettay</span>, <span class="vcard">Rafael Weinstein</span>, <span class="vcard">Richard Bradshaw</span>, <span class="vcard">Ruud Steltenpool</span>, <span class="vcard">Sam Dutton</span>, <span class="vcard">Sergey G. Grekhov</span>, <span class="vcard">Shinya Kawanaka</span>, <span class="vcard">Tab Atkins</span>, <span class="vcard">Takashi Sakamoto</span>, and <span class="vcard">Yoshinori Sano</span> for their comments and contributions to this specification.</p>

      <p>This list is too short. There's a lot of work left to do. Please contribute by reviewing and filing bugs&mdash;and don't forget to ask the editor to add your name into this section.</p>
    </section>

  </body>
</html>
